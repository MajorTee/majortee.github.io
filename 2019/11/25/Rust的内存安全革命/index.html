<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="Hee"><title>Rust的内存安全革命 · HeeC'Blog</title><meta name="description" content="介绍
中译版来源：https://szpzs.oschina.io/2018/04/28/rust-memory-safety-revolution/#more

Rust是一种年轻的编程语言，为程序代码带来了新的质量。 你可能听说过它是快速的、安全的或容易实现并发的。 本文集中介绍Rust最重要的"><meta name="keywords" content="text"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/bootstrap.min.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="stylesheet" href="/css/style.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><meta name="generator" content="Hexo 4.2.0"><link rel="stylesheet" href="/css/prism.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head><body><div id="stage" class="container"><div class="row"><div id="side-bar" class="col-sm-3 col-xs-12 side-container invisible"><div class="vertical-text site-title"><h3 tabindex="-1" class="site-title-small"><a href="/" class="a-title">HeeC</a></h3><h1 tabindex="-1" class="site-title-large"><a href="/" class="a-title">笔记记录</a></h1><!--h6(onclick="triggerSiteNav()") Trigger--></div><br class="visible-lg visible-md visible-sm"><div id="site-nav" class="site-title-links"><ul><li><a href="/">首页</a></li><li><a href="/archives">归档</a></li><li><a href="/categories">分类</a></li><li><a href="/tags">标签</a></li><li class="soc"><a href="http://yoursite.com/atom.xml" target="_blank" rel="noopener noreferrer"><i class="fa fa-rss">&nbsp;</i></a></li></ul><div class="visible-lg visible-md visible-sm site-nav-footer"><br class="site-nav-footer-br"><footer><p>&copy;&nbsp;2020&nbsp;<a target="_blank" href="http://yoursite.com" rel="noopener noreferrer">Hee</a></p><p>Theme&nbsp;<a target="_blank" href="https://github.com/SumiMakito/hexo-theme-typography" rel="noopener noreferrer">Typography</a>&nbsp;by&nbsp;<a target="_blank" href="https://www.keep.moe" rel="noopener noreferrer">Makito</a></p><p>Proudly published with&nbsp;<a target="_blank" href="https://hexo.io" rel="noopener noreferrer">Hexo</a></p></footer></div></div></div><div id="main-container" class="col-sm-9 col-xs-12 main-container invisible"><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post-container"><p class="post-title"><a>Rust的内存安全革命</a></p><p class="post-meta"><span class="date meta-item">发布于&nbsp;2019-11-25</span><span class="meta-item"><i class="fa fa-folder"></i><span>&nbsp;</span><a href="/categories/编程语言/" title="编程语言" class="a-tag">编程语言</a><span>&nbsp;</span></span><span class="meta-item"><i class="fa fa-tag"></i><span>&nbsp;</span><a href="/tags/rust/" title="rust" class="a-tag">rust</a><span>&nbsp;</span></span></p><p class="post-abstract"><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><blockquote>
<p>中译版来源：<a href="https://szpzs.oschina.io/2018/04/28/rust-memory-safety-revolution/#more" target="_blank" rel="noopener">https://szpzs.oschina.io/2018/04/28/rust-memory-safety-revolution/#more</a></p>
</blockquote>
<p>Rust是一种年轻的编程语言，为程序代码带来了新的质量。 你可能听说过它是快速的、安全的或容易实现并发的。 本文集中介绍Rust最重要的核心特性：内存管理。 该核心特性是Rust的主要创新之一，它的许多独特的特点是基于这种核心特性的。</p>
<p>本文是写给不知道Rust或刚刚开始学习它的程序员的。对于熟悉C、C++或其他使用手动管理内存以及使用垃圾回收器语言的读者来说会更容易理解Rust的特点。 本文是一个旨在介绍Rust核心概念并鼓励进一步学习的高层次介绍。本文不是教程，最后也没有 Hello Wrold 的Rust例子。</p>
<a id="more"></a>

<h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><p>现代应用程序使用计算机的内存主要有两种方式：栈和堆。这可能不适用于使用汇编或编写嵌入式系统软件的情况，但让我们还是关注一般的应用程序的场景。</p>
<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>随着程序进入和退出某些区域（通常是函数），以及循环和分支代码块，栈会自动扩展和缩小。所有现代的、高于汇编语言的语言都会自动执行此操作。它们的行为都是相似的，程序员声明变量，使用它，然后丢弃它。 编译器基于代码区域边界知道何时必须保留内存以及何时清除内存。 这是一个严格的流程，但它快速、安全且易于使用。</p>
<pre class="line-numbers language-rust"><code class="language-rust">main <span class="token punctuation">{</span>    
    A <span class="token operator">=</span> <span class="token number">1</span>       <span class="token comment" spellcheck="true">// 创建 A    </span>
    <span class="token keyword">loop</span> <span class="token punctuation">{</span>        
        B <span class="token operator">=</span> <span class="token number">2</span>   <span class="token comment" spellcheck="true">// 创建 B                </span>
        <span class="token comment" spellcheck="true">// 删除 B    </span>
    <span class="token punctuation">}</span>                
    <span class="token comment" spellcheck="true">// 删除 A</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>对堆的处理更自由。 程序员可以从代码中的任何一点来请求它的一部分，然后在任何其他点释放它。 它并不明显与程序流程结合，编译器无法确定何时以及如何处理它。程序员有责任对其进行正确处理。</p>
<p>内存<strong>首先</strong>必须被获取到，<strong>然后</strong>被使用，<strong>最后</strong>被仅释放<strong>一次</strong>。这三个步骤似乎很简单，但将其与其他应用程序的流程混合会变得棘手，并且违反其中一个步骤都是灾难性的。 有时候一个错误可能没有任何后果，但是在其他时候，应用程序可能会被终止，甚至更糟糕的是，它的内存可能会悄无声息地被破坏。 这种行为不是确定性的。</p>
<pre class="line-numbers language-rust"><code class="language-rust">main <span class="token punctuation">{</span>    
    A <span class="token operator">=</span> <span class="token function">allocate</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// 获取    </span>
    <span class="token function">do_stuff</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span>     <span class="token comment" spellcheck="true">// 使用    </span>
    <span class="token function">release</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span>      <span class="token comment" spellcheck="true">// 释放                    </span>
    <span class="token comment" spellcheck="true">// 删除指针</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="泄露"><a href="#泄露" class="headerlink" title="泄露"></a>泄露</h3><p>当内存没有被正确释放当时候，泄露就发生了。内存泄漏成为一个致命的负担，使得应用程序比实际所需使用更多的资源。在极端情况下，如果所有的内存都被占用，并且仍然有更多的需求，它会使程序甚至整个系统崩溃。</p>
<pre class="line-numbers language-rust"><code class="language-rust">main <span class="token punctuation">{</span>    A <span class="token operator">=</span> <span class="token function">allocate</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// 获取    do_stuff(A)     // 使用                    // &lt;运行时错误> 从未释放                    // 删除指针}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h3 id="释放后使用"><a href="#释放后使用" class="headerlink" title="释放后使用"></a>释放后使用</h3><p>当内存被释放后程序还尝试去使用这块内存，这就是释放后使用。如果内存被还给了操作系统，而我们又尝试去访问它，这会导致致命的段错误，程序会立即被结束。另一个有趣的部分是当被释放的内存被分配器缓存并在下次获取时被重用，这使两个随机部分的代码使用相同位置的内存。</p>
<pre class="line-numbers language-rust"><code class="language-rust">main <span class="token punctuation">{</span>
    A <span class="token operator">=</span> <span class="token function">allocate</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// 获取    </span>
    <span class="token function">release</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span>      <span class="token comment" spellcheck="true">// 释放    </span>
    <span class="token function">do_stuff</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span>     <span class="token comment" spellcheck="true">// &lt;运行时错误> 使用无效指针                    </span>
    <span class="token comment" spellcheck="true">// 删除指针</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="重复释放"><a href="#重复释放" class="headerlink" title="重复释放"></a>重复释放</h3><p>内存被释放两次就是重复释放。如果内存被还回操作系统，它就终止程序对它对访问。重复释放的后果很大程度上取决于分配器，释放内存在其他地方使用或只是崩溃。</p>
<pre class="line-numbers language-rust"><code class="language-rust">main <span class="token punctuation">{</span>
    A <span class="token operator">=</span> <span class="token function">allocate</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// 获取    </span>
    <span class="token function">do_stuff</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span>     <span class="token comment" spellcheck="true">// 使用    </span>
    <span class="token function">release</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span>      <span class="token comment" spellcheck="true">// 释放    </span>
    <span class="token function">release</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span>      <span class="token comment" spellcheck="true">// &lt;运行时错误> 释放无效指针                    </span>
    <span class="token comment" spellcheck="true">// 删除指针</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="传统解决方法"><a href="#传统解决方法" class="headerlink" title="传统解决方法"></a>传统解决方法</h1><p>堆管理是个非常古老的问题，程序员发明了许多工具来减轻它。有两种主要的方法，都被证明是有用的，但每一种都有严重缺陷。</p>
<h2 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h2><p>这是一个简单的方法。程序获得特殊的机制检测到从某时刻开始给定的内存块将永远不会被使用，因此它可以安全释放。该方法防止了内存泄露、释放后使用、重复释放。证明内存永远不会被再次使用的最简单的方法是证明它是不可访问的。当程序将内存的地址存储在栈上、静态变量或堆上时，该内存是可到访问的，堆本身是可到达的，因此可以在不猜测的情况下获得。而内存本身是可访问的，因此可以毫无疑问地获得它。</p>
<pre class="line-numbers language-rust"><code class="language-rust">main <span class="token punctuation">{</span>
   <span class="token punctuation">...</span>
   A <span class="token operator">=</span> <span class="token operator">&lt;</span>pointer to<span class="token operator">></span>──────┐
   <span class="token punctuation">...</span>                   <span class="token operator">|</span>
<span class="token punctuation">}</span>                        │
                         ▼
╔══ HEAP ALLOCATED ════════╗
║ AA <span class="token operator">=</span> <span class="token string">"reachable"</span>         ║
║ AB <span class="token operator">=</span> <span class="token operator">&lt;</span>pointer to<span class="token operator">></span>──────┐ ║
╚════════════════════════│═╝
                         ▼
╔══ HEAP ALLOCATED ════════╗
║ ABA <span class="token operator">=</span> <span class="token string">"also reachable"</span>   ║
╚══════════════════════════╝
╔══ HEAP ALLOCATED ════════╗
║ BA <span class="token operator">=</span> <span class="token string">"unreachable"</span>       ║
║ BB <span class="token operator">=</span> <span class="token operator">&lt;</span>pointer to<span class="token operator">></span>──────┐ ║
╚════════════════════════│═╝
                         ▼
╔══ HEAP ALLOCATED ════════╗
║ BBA <span class="token operator">=</span> <span class="token string">"also unreachable"</span> ║
╚══════════════════════════╝<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>有许多智能的策略来检查可访问性，但它们都会产生显著的开销。例如，引用计数器会增加内存使用量并为每个堆访问增加开销。另一方面，追踪垃圾回收器允许自由访问，但引入了大量的内存可访问性分析，这些分析可以在后台不断运行，或者为了清理内存可以完全停止程序的执行。 无论如何，垃圾回收器都会为应用程序增加额外的工作量并增加内存使用量。</p>
<h2 id="严格的规则"><a href="#严格的规则" class="headerlink" title="严格的规则"></a>严格的规则</h2><p>因此垃圾回收器是一个很好但消耗大量资源的解决方案。但是，如果成本难以承受或者根本没有可能使用它，我们可以做些什么呢？ 程序员发明了一个特殊的规则，它使内存管理更容易。 它是基于所有权和生命周期的规则。</p>
<h3 id="所有权"><a href="#所有权" class="headerlink" title="所有权"></a>所有权</h3><p>所有权是这样的一个想法，可以有很多指向分配内存的指针，但只有其中一个被视为拥有该内存。当拥有所有权的指针被销毁时，应该使用它来释放分配给它的内存。非所有权的指针可以被创建和销毁任意个，但它们永远不应该用于释放内存。这使得内存管理更加清晰，因为只有一个重要指针要跟踪和释放。它还解决了前面提到的三个堆问题中的两个问题：泄漏和重复释放。所有权可能是API和程序流程中的一个软性协议，但某些语言和库提供的工具使得此策略的执行更加明确且不易出错。例如，现代C++提供了内置的智能指针，它明确表示有拥有权的指针并实现像销毁时释放的合适行为。</p>
<pre class="line-numbers language-rust"><code class="language-rust">main <span class="token punctuation">{</span>
    A <span class="token operator">=</span> <span class="token function">allocate</span><span class="token punctuation">(</span><span class="token punctuation">)</span>      <span class="token comment" spellcheck="true">// 获取</span>
    <span class="token function">do_stuff</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span>         <span class="token comment" spellcheck="true">// 使用</span>
    <span class="token function">release</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span>          <span class="token comment" spellcheck="true">// 释放, 指针拥有内存</span>
                        <span class="token comment" spellcheck="true">// 删除指针</span>
<span class="token punctuation">}</span>
<span class="token function">do_stuff</span><span class="token punctuation">(</span>B<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">do_more_stuff</span><span class="token punctuation">(</span>B<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// 使用</span>
                        <span class="token comment" spellcheck="true">// 不会释放，该指针不是所有权的指针</span>
                        <span class="token comment" spellcheck="true">// 删除指针</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>生命周期是程序执行过程中的一段时间，而这段时间内一段特定的数据被有效使用。处理堆分配的内存指针时，这是非常重要的属性，这些指针并不拥有内存。 只要拥有内存的指针不释放内存，它们就可以安全使用。而有所有权的指针释放内存之后，再使用它们就是错误，因为它们的生命周期结束了。值得注意的是，任何包含给定生命期周期的指针的结构都应该被认为具有不超过指针的生命期周期。这不是一个可以执行的简单的规则，但它可以防止前面提到的第三个堆内存问题：释放后使用。 这补充了所有权的保证，使得程序的完全内存安全，而无需垃圾回收器这样的开销。</p>
<pre class="line-numbers language-rust"><code class="language-rust">main <span class="token punctuation">{</span>
    A <span class="token operator">=</span> <span class="token function">allocate</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// A's lifetime begins</span>
    <span class="token function">do_stuff</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span>     <span class="token comment" spellcheck="true">// use A</span>
    B <span class="token operator">=</span> A           <span class="token comment" spellcheck="true">// B's lifetime begins</span>
    <span class="token function">do_stuff</span><span class="token punctuation">(</span>B<span class="token punctuation">)</span>     <span class="token comment" spellcheck="true">// use B</span>
    <span class="token function">release</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span>      <span class="token comment" spellcheck="true">// release, A's and B's lifetimes end</span>
    <span class="token function">do_stuff</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span>     <span class="token comment" spellcheck="true">// &lt;RUN TIME FAIL> use A after its lifetime ended</span>
    <span class="token function">do_stuff</span><span class="token punctuation">(</span>B<span class="token punctuation">)</span>     <span class="token comment" spellcheck="true">// &lt;RUN TIME FAIL> use B after its lifetime ended</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="Rust"><a href="#Rust" class="headerlink" title="Rust"></a>Rust</h1><p>有时Rust被描述为混合解决方案。 实际上，它所做的只是强化代码中的所有权和生命周期规则，然而结果是，用Rust写代码非常安全和无忧无虑，它类似于垃圾回收语言。编译器进行静态校验该程序是内存安全的，如果无法校验它是内存安全的，编译器会产生一个指出潜在风险的错误。 当编译通过后，代码保证不会导致内存损坏。 因为这些校验在构建输出二进制文件之前都发生了，所以这个过程对程序的执行没有任何影响，就像它是用纯C或C++编写的一样轻量。</p>
<h2 id="所有权-1"><a href="#所有权-1" class="headerlink" title="所有权"></a>所有权</h2><p>Rust有非常严格的所有权概念。每一块被分配的内存被一些结构的单独实例所拥有。这些结构可以是任何类型，但通常他们最终是某种来自标准库的集合或Box（Rust的智能指针）。这些包装器负责在自己被销毁的时候释放所拥有的内存。没有简单的方法来显式分配内存和获取原始指针，而不需要任何负责任的包装器。</p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function">my_fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> my_box <span class="token operator">=</span> Box<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token number">1234</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 获取</span>
    <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> my_box<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// 使用</span>
                                    <span class="token comment" spellcheck="true">// 删除 my_box,</span>
                                    <span class="token comment" spellcheck="true">// 释放内存</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="递归销毁"><a href="#递归销毁" class="headerlink" title="递归销毁"></a>递归销毁</h3><p>所有权是递归的，所以如果一个结构存储另一个结构的值，它将获得后者及其所有子结构的所有权。这也意味着，当容器被销毁时，它必须递归地销毁其所有内容。Rust处理这样的情况可以说是开箱即用一样轻松。所有结构都定义了析构器，它遍历所有字段并首先销毁它们。结构的作者可以在销毁期间添加自己的步骤，例如在编写客户端时关闭数据库连接，但是在此之后字段仍然会被逐一销毁。默认的处理行为在绝大多数情况下都是足够的，因此结构很少会定义析构函数，但是不管有没有定义析构函数，它们都不会泄漏内存。</p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token keyword">struct</span> MyStruct <span class="token punctuation">{</span>                       <span class="token comment" spellcheck="true">// 结构定义</span>
    my_box<span class="token punctuation">:</span> Box<span class="token operator">&lt;</span>u32<span class="token operator">></span><span class="token punctuation">,</span>                   <span class="token comment" spellcheck="true">// 它只有一个字段,</span>
                                        <span class="token comment" spellcheck="true">// 在堆上一个持有整数的Box类型数据</span>
<span class="token punctuation">}</span>
<span class="token keyword">fn</span> <span class="token function">my_fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> my_struct <span class="token operator">=</span> MyStruct <span class="token punctuation">{</span>          <span class="token comment" spellcheck="true">// 创建结构实例</span>
        my_box<span class="token punctuation">:</span> Box<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token number">1234</span><span class="token punctuation">)</span><span class="token punctuation">,</span>         <span class="token comment" spellcheck="true">// 获取内存</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> my_struct<span class="token punctuation">.</span>my_box<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 使用</span>
                                        <span class="token comment" spellcheck="true">// 删除 my_struct,</span>
                                        <span class="token comment" spellcheck="true">// 同时删除 my_box,</span>
                                        <span class="token comment" spellcheck="true">// 释放内存</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="用栈替代堆"><a href="#用栈替代堆" class="headerlink" title="用栈替代堆"></a>用栈替代堆</h3><p>Rust的所有权模式带来了一个强大的特性：复杂的堆管理简化为简单的栈管理。程序员不需要担心如何分配和释放内存，这些工作都通过使用局部变量来处理。甚至即使结构里嵌套了许多堆内存的引用，在栈上也总是只有一个根结构，当程序不再需要它的时候，它会自动销毁。</p>
<h2 id="生命周期-1"><a href="#生命周期-1" class="headerlink" title="生命周期"></a>生命周期</h2><p>不幸的是，编写那些访问数据需要拥有这些数据的程序并不方便。Rust提供普通的、非智能的、没有所有权的引用，这种引用使得没有所有权的访问成为可能。当这样的引用被创建时，它引用的值是借用的。借用会创建一个双向关系：引用必须具有不超过它引用的值的生命周期，但该值在引用的生命周期内不得移动。这两条规则任何一条被破坏的话，引用所指向的就是无效内存。Rust静态地跟踪并强制执行生命周期的正确性并拒绝危险的程序执行流程。</p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function">valid_flow</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> value <span class="token operator">=</span> <span class="token string">"abc"</span><span class="token punctuation">.</span><span class="token function">to_string</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 创建值</span>
    <span class="token keyword">let</span> borrow <span class="token operator">=</span> <span class="token operator">&amp;</span>value<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 创建借用</span>
    <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">// 使用值但是没有移动它</span>
    <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> borrow<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// 使用借用</span>
                                    <span class="token comment" spellcheck="true">// 删除借用</span>
                                    <span class="token comment" spellcheck="true">// 安全地删除值，</span>
                                    <span class="token comment" spellcheck="true">// 因为它不再被借用</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="递归借用"><a href="#递归借用" class="headerlink" title="递归借用"></a>递归借用</h3><p>结构的生命周期永远不能超过它们的任何字段的生命周期。如果其中一个字段恰好是引用，则必须证明整个结构实例在引用值之前被销毁。如果存在对具有生命周期限制的结构的引用，则引用本身的生命周期不能超过结构。只要编译器可以证明它是安全的，这种关系就可以嵌套并绑定任意次数。当编译器无法猜测正确的关系时，可以用简单的语法明确定义它们。</p>
<pre class="line-numbers language-rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function">borrow_outlives_value</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token operator">&amp;</span>String <span class="token punctuation">{</span>
    <span class="token keyword">let</span> value <span class="token operator">=</span> <span class="token string">"abc"</span><span class="token punctuation">.</span><span class="token function">to_string</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 创建值</span>
    <span class="token keyword">let</span> borrow <span class="token operator">=</span> <span class="token operator">&amp;</span>value<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 创建借用</span>
    <span class="token keyword">return</span> borrow                   <span class="token comment" spellcheck="true">// 借用没有被删除</span>
                                    <span class="token comment" spellcheck="true">// &lt;编译时错误> 删除值,</span>
                                    <span class="token comment" spellcheck="true">// 但是它仍然被借用</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="规则的妥协"><a href="#规则的妥协" class="headerlink" title="规则的妥协"></a>规则的妥协</h1><p>认为每一个系统都可以用限制性的、静态证明的安全性代码来表达是天真的想当然。在绝大多数的情况下，规则可以胜任，但有时规则也必须进行妥协，Rust提供工具来做这件事。</p>
<h2 id="包装器"><a href="#包装器" class="headerlink" title="包装器"></a>包装器</h2><p>标准库提供一些包装器将所有权和借用的检查推迟到运行时。这就使有效性检查程序不那么繁忙，并提供了灵活性和很少的运行时开销。例如，Rc是一个没有所有者的Box（带有智能指针的内存）。 它是一个有引用计数器的可被垃圾回收的内存，它的最后一个引用消失的时候，它就被销毁。 Rust提供了更多的包装器，但它们稍微超出了本介绍的范围，它们适用于运行时规则，本文没有涉及。</p>
<h2 id="不安全代码"><a href="#不安全代码" class="headerlink" title="不安全代码"></a>不安全代码</h2><p>当在库和工具中进入足够低的层次时，Rust的安全保证变得无法应用。 例如，box和集合触及内存分配和指针，但没有安全保证，因为它们自己做安全保证。 它们可以写在Rust中，因为它们的代码明确标记为不安全。这使得完全忽略安全检查，但这非常危险。 所有外部C库包装器在某些层次也必须使用不安全的代码。 他们定义安全规则，使其与其余代码无缝集成。 不安全的代码是Rust强大能力的来源，但它带来了巨大的责任。 应尽可能避免使用它。</p>
<h1 id="实际情况"><a href="#实际情况" class="headerlink" title="实际情况"></a>实际情况</h1><p>Rust看起来不错，它是由聪明的人使用其他聪明人的学术研究设计的，但它真的有用吗？是的，的确有用。大多数情况下，它只会强制元素之间的明确关系，进行合理安全的设计。毕竟，Rust是与Firefox Web浏览器的未来引擎Servo并行设计的。从一开始，它不仅在理论上是好的，而且在实际的、复杂的软件开发中也被证明是可用的。经过一年使用Rust进行商业编程后，我可以确认，Rust的规则不是一种负担，而是在架构和稳定性保证方面提供了很大的帮助。 我真的相信，Rust这种语言是属于未来的，我强烈推荐大家使用它。</p>
<blockquote>
<p><em>原文链接：</em> <a href="https://anixe.pl/content/news/rust_memory_safety_revolution" target="_blank" rel="noopener">https://anixe.pl/content/news/rust_memory_safety_revolution</a></p>
</blockquote>
</p></div><div class="share"><span>分享到</span>&nbsp;<span class="soc"><a href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank" class="fa fa-bookmark"></a></span><span class="soc"><a href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));" class="fa fa-weibo"></a></span><span class="soc"><a href="http://twitter.com/home?status=http://yoursite.com/2019/11/25/Rust的内存安全革命/%20HeeC' target="_blank" rel="noopener"Blog%20Rust的内存安全革命" class="fa fa-twitter"></a></span></div><div class="pagination"><p class="clearfix"><span class="pre pagbuttons"><a role="navigation" href="/2019/11/26/Go%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" title="Go语言中的面向对象"><i class="fa fa-angle-double-left"></i>&nbsp;上一篇: Go语言中的面向对象</a></span><span>&nbsp;</span><span class="next pagbuttons"><a role="navigation" href="/2019/11/14/%E5%A4%9Agit%E8%B4%A6%E5%8F%B7%E9%97%AE%E9%A2%98/" title="多git账号问题">下一篇: 多git账号问题&nbsp;<i class="fa fa-angle-double-right"></i></a></span></p></div></div></div></div><div class="visible-xs site-bottom-footer"><footer><p>&copy;&nbsp;2020&nbsp;<a target="_blank" href="http://yoursite.com" rel="noopener noreferrer">Hee</a></p><p>Theme&nbsp;<a target="_blank" href="https://github.com/SumiMakito/hexo-theme-typography" rel="noopener noreferrer">Typography</a>&nbsp;by&nbsp;<a target="_blank" href="https://www.keep.moe" rel="noopener noreferrer">Makito</a></p><p>Proudly published with&nbsp;<a target="_blank" href="https://hexo.io" rel="noopener noreferrer">Hexo</a></p></footer></div></div></div></div><script src="/js/jquery-3.1.0.min.js"></script><script src="/js/bootstrap.min.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script><script src="/js/google-analytics.js"></script><script src="/js/typography.js"></script></body></html>