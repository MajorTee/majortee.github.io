<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="Hee"><title>Java基础篇-篇一（基本功） · HeeC'Blog</title><meta name="description" content="基础篇（一）基本功
面向对象的特征
封装的目的是隐藏事务内部的实现细节，以便提高安全性和简化编程。封装提供了合理的边界，避免外部调用者接触到内部的细节。我们在日常开发中，因为无意间暴露了细节导致的难缠bug太多了，比如在多线程环境暴露内部状态，导致的并发修改问题。从另外一个角度看，封装这种隐藏，也提"><meta name="keywords" content="text"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/bootstrap.min.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="stylesheet" href="/css/style.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><meta name="generator" content="Hexo 4.2.0"><link rel="stylesheet" href="/css/prism.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head><body><div id="stage" class="container"><div class="row"><div id="side-bar" class="col-sm-3 col-xs-12 side-container invisible"><div class="vertical-text site-title"><h3 tabindex="-1" class="site-title-small"><a href="/" class="a-title">HeeC</a></h3><h1 tabindex="-1" class="site-title-large"><a href="/" class="a-title">笔记记录</a></h1><!--h6(onclick="triggerSiteNav()") Trigger--></div><br class="visible-lg visible-md visible-sm"><div id="site-nav" class="site-title-links"><section><a href="#">站内搜索</a><div id="site_search"><span style="&lt;%- wrapStyle %&gt;" class="local-search local-search-google local-search-plugin"><input id="local-search-input" type="search" style="&lt;%- inputStyle %&gt;" class="local-search-input-cls"><div id="local-search-result" class="local-search-result-cls"></div></span></div></section><ul><li><a href="/">首页</a></li><li><a href="/archives">归档</a></li><li><a href="/categories">分类</a></li><li><a href="/tags">标签</a></li><li class="soc"><a href="https://github.com/MajorTee" target="_blank" rel="noopener noreferrer"><i class="fa fa-github">&nbsp;</i></a><a href="http://yoursite.com/atom.xml" target="_blank" rel="noopener noreferrer"><i class="fa fa-rss">&nbsp;</i></a></li><div class="visible-lg"><br class="site-nav-footer-br"><br class="site-nav-footer-br"></div></ul><div class="visible-lg visible-md visible-sm site-nav-footer"><br class="site-nav-footer-br"><footer><p>&copy;&nbsp;2020&nbsp;<a target="_blank" href="http://yoursite.com" rel="noopener noreferrer">Hee</a></p><p>Theme&nbsp;<a target="_blank" href="https://github.com/SumiMakito/hexo-theme-typography" rel="noopener noreferrer">Typography</a>&nbsp;by&nbsp;<a target="_blank" href="https://www.keep.moe" rel="noopener noreferrer">Makito</a></p><p>Proudly published with&nbsp;<a target="_blank" href="https://hexo.io" rel="noopener noreferrer">Hexo</a></p></footer></div></div></div><div id="main-container" class="col-sm-9 col-xs-12 main-container invisible"><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post-container"><p class="post-title"><a>Java基础篇-篇一（基本功）</a></p><p class="post-meta"><span class="date meta-item">发布于&nbsp;2019-09-10</span><span class="meta-item"><i class="fa fa-comment-o"></i><span>&nbsp;</span><a href="/2019/09/10/Java%E5%9F%BA%E7%A1%80%E7%AF%87-%E7%AF%87%E4%B8%80%EF%BC%88%E5%9F%BA%E6%9C%AC%E5%8A%9F%EF%BC%89/#comments">评论</a></span><span class="meta-item"><i class="fa fa-folder"></i><span>&nbsp;</span><a href="/categories/面试/" title="面试" class="a-tag">面试</a><span>&nbsp;</span></span><span class="meta-item"><i class="fa fa-tag"></i><span>&nbsp;</span><a href="/tags/Java/" title="Java" class="a-tag">Java</a><span>&nbsp;</span></span></p><p class="post-abstract"><h1 id="基础篇（一）"><a href="#基础篇（一）" class="headerlink" title="基础篇（一）"></a>基础篇（一）</h1><h2 id="基本功"><a href="#基本功" class="headerlink" title="基本功"></a>基本功</h2><a id="more"></a>
<h3 id="面向对象的特征"><a href="#面向对象的特征" class="headerlink" title="面向对象的特征"></a>面向对象的特征</h3><ul>
<li>封装的目的是隐藏事务内部的实现细节，以便提高安全性和简化编程。封装提供了合理的边界，避免外部调用者接触到内部的细节。我们在日常开发中，因为无意间暴露了细节导致的难缠bug太多了，比如在多线程环境暴露内部状态，导致的并发修改问题。从另外一个角度看，封装这种隐藏，也提供了简化的界面，避免太多无意义的细节浪费调用者的精力。</li>
<li>继承是代码复用的基础机制，类似于我们对于马、白马、黑马的归纳总结。但要注意，继承可以看作是非常紧耦合的一种关系，父类代码修改，子类行为也会变动。在实践中，过度滥用继承，可能会起到反效果。</li>
<li>多态，你可能立即会想到重写（override）和重载（overload）、向上转型。简单说，重写是父子类中相同名字和参数的方法，不同的实现；重载则是相同名字的方法，但是不同的参数，本质上这些方法签名是不一样的，为了更好说明，请参考下面的样例代码 </li>
</ul>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">public int doSomething() {
    return 0;
}
// 输入参数不同，意味着方法签名不同，重载的体现
public int doSomething(List<String> strs) {
    return 0;
}
// return类型不一样，编译不能通过
public short doSomething() {
    return 0;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>一个小问题，方法名称和参数一致，但是返回值不同，这种情况在Java代码中算是有效的重载吗？ 答案是不是的，编译都会出错的。<br>进行面向对象编程，掌握基本的设计原则是必须的，我今天介绍最通用的部分，也就是所谓的<em>S.O.L.I.D</em>原则。</p>
<ul>
<li>单一职责（Single Responsibility），类或者对象最好是只有单一职责，在程序设计中如果发现某个类承担着多种义务，可以考虑进行拆分。</li>
<li>开关原则（Open-Close, Open for extension, close for modification），设计要对扩展开放，对修改关闭。换句话说，程序设计应保证平滑的扩展性，尽量避免因为新增同类功能而修改已有实现，这样可以少产出些回归（regression）问题。</li>
<li>里氏替换（Liskov Substitution），这是面向对象的基本要素之一，进行继承关系抽象时，凡是可以用父类或者基类的地方，都可以用子类替换。</li>
<li>接口分离（Interface Segregation），我们在进行类和接口设计时，如果在一个接口里定义了太多方法，其子类很可能面临两难，就是只有部分方法对它是有意义的，这就破坏了程序的内聚性。<br>对于这种情况，可以通过拆分成功能单一的多个接口，将行为进行解耦。在未来维护中，如果某个接口设计有变，不会对使用其他接口的子类构成影响。</li>
<li>依赖反转（Dependency Inversion），实体应该依赖于抽象而不是实现。也就是说高层次模块，不应该依赖于低层次模块，而是应该基于抽象。实践这一原则是保证产品代码之间适当耦合度的法宝。 </li>
</ul>
<h4 id="OOP原则实践中的取舍"><a href="#OOP原则实践中的取舍" class="headerlink" title="OOP原则实践中的取舍"></a>OOP原则实践中的取舍</h4><p>值得注意的是，现代语言的发展，很多时候并不是完全遵守前面的原则的，比如， Java 10中引入了本地方法类型推断和var类型。按照，里氏替换原则，我们通常这样定义变量：</p>
<blockquote>
<p>List<String> list = new ArrayList&lt;&gt;(); </p>
</blockquote>
<p>如果使用var类型，可以简化为</p>
<p>var lis = new ArrayLis<String>();</p>
<p>但是， list 实际会被推断为 <strong>“ArrayList &lt; String &gt;”</strong></p>
<blockquote>
<p>ArrayList<String> list = new ArrayList<String>();</p>
</blockquote>
<p>理论上，这种语法上的便利，其实是增强了程序对实现的依赖，但是微小的类型泄漏却带来了书写的变量和代码可读性的提高，所以，实践中我们还是要按照得失利弊进行选择，而不是一味得遵循原则。</p>
<h5 id="OOP原则在面试题目中的分析"><a href="#OOP原则在面试题目中的分析" class="headerlink" title="OOP原则在面试题目中的分析"></a>OOP原则在面试题目中的分析</h5><p>我在以往面试中发现，即使是有多年编程经验的工程师，也还没有真正掌握面向对象设计的基本的原则，如开关原则（Open-Close）。看看下面这段代码，改编自朋友圈盛传的某伟大公司产品代码，你觉得可以利用面向对象设计原则如何改进？</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">public class VIPCenter {
void serviceVIP(T extend User user>) {
    if (user instanceof SlumDogVIP) {
    // 穷X VIP，活动抢的那种
    // do somthing
    } else if(user instanceof RealVIP) {
    // do somthing
    }
// ...
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这段代码的一个问题是，业务逻辑集中在一起，当出现新的用户类型时，比如，大数据发现了我们是肥羊，需要去收获一下， 这就需要直接去修改服务方法代码实现，这可能会意外影响不相关的某个用户类型逻辑。利用开关原则，我们可以尝试改造为下面的代码：</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">public class VIPCenter {
private Map<User.TYPE, ServiceProvider> providers;
    void serviceVIP(T extend User user） {
        providers.get(user.getType()).service(user);
    }
}
interface ServiceProvider{
    void service(T extend User user) ;
}
class SlumDogVIPServiceProvider implements ServiceProvider{
    void service(T extend User user){
    // do somthing
    }
}
class RealVIPServiceProvider implements ServiceProvider{
    void service(T extend User user) {
    // do something
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>上面的示例，将不同对象分类的服务方法进行抽象，把业务逻辑的紧耦合关系拆开，实现代码的隔离保证了方便的扩展。</p>
<h3 id="int和Integer的区别"><a href="#int和Integer的区别" class="headerlink" title="int和Integer的区别"></a>int和Integer的区别</h3><p>int是我们常说的整形数字，是Java的8个原始数据类型（Primitive Types， boolean、 byte 、 short、 char、 int、 float、 double、 long）之一。 Java语言虽然号称一切都是对象，但原始数据类型是例外。</p>
<p>Integer是int对应的包装类，它有一个int类型的字段存储数据，并且提供了基本操作，比如数学运算、 int和字符串之间转换等。在Java 5中，引入了自动装箱和自动拆箱功能（boxing/unboxing）， Java可以根据上下文，自动进行转换，极大地简化了相关编程。</p>
<p>关于Integer的值缓存，这涉及Java 5中另一个改进。构建Integer对象的传统方式是直接调用构造器，直接new一个对象。但是根据实践，我们发现大部分数据操作都是集中在有限的、较小的数值范围，因而，在Java 5中新增了静态工厂方法<code>valueOf</code>，在调用它的时候会利用一个缓存机制，带来了明显的性能改进。按照Javadoc， 这个值默认缓存是-128到127之间。</p>
<h5 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h5><ul>
<li>自动装箱/自动拆箱是发生在什么阶段？</li>
<li>自动装箱的时候，缓存机制起作用吗？</li>
<li>为什么需要原始数据类型， Java的对象似乎也很高效，应用中具体会产生哪些差异？</li>
<li>阅读过Integer源码吗？分析下类或某些方法的设计要点。  </li>
</ul>
<ol>
<li><p>理解自动装箱、拆箱<br>自动装箱实际上算是一种语法糖，可以简单理解为平台为我们自动进行了一些转换，保证不同的写法在运行时等价，它们发生在编译阶段，也就是生成的字节码是一致的。</p>
<p>像前面提到的整数， 替我们自动把装箱转换为 <code>Integer.valueOf()</code>，把拆箱替换为 <code>Integer.intValue()</code>，这似乎这也顺道回答了第二个问题，既然调用的是 <code>Integer.valueOf</code>，<br>自然能够得到缓存的好处啊。<br>如何程序化的验证上面的结论呢？<br>你可以写一段简单的程序包含下面两句代码，然后反编译一下。当然，这是一种从表现倒推的方法，大多数情况下，我们还是直接参考规范文档会更加可靠，毕竟软件承诺的是遵循规范，而不是保持当前行为。</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">Integer integer = 1;
int unboxing = integer ++;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>反编译输出： </p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">1: invokestatic #2 // Method
java/lang/Integer.valueOf:(I)Ljava/lang/Integer;
8: invokevirtual #3 // Method
java/lang/Integer.intValue:()I
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>这种缓存机制并不是只有Integer才有，同样存在于其他的一些包装类，比如：</p>
<ul>
<li><p>Boolean，缓存了true/false对应实例，确切说，只会返回两个常量实例Boolean.TRUE/FALSE。</p>
</li>
<li><p>Short，同样是缓存了-128到127之间的数值。</p>
</li>
<li><p>Byte，数值有限，所以全部都被缓存。</p>
</li>
<li><p>Character，缓存范围<code>&#39;\u0000&#39;</code>到 <code>&#39;\u007F&#39;</code>。 原则上， 建议避免无意中的装箱、拆箱行为，尤其是在性能敏感的场合，创建10万个Java对象和10万个整数的开销可不是一个数量级的，不管是内存使用还是处理速度，光是对象头的空间占用就已经是数量级的差距了。</p>
</li>
</ul>
<p>我们其实可以把这个观点扩展开，使用原始数据类型、数组甚至本地代码实现等，在性能极度敏感的场景往往具有比较大的优势，用其替换掉包装类、动态数组（如ArrayList）等可以作为性能优化的备选项。一些追求极致性能的产品或者类库，会极力避免创建过多对象。当然，在大多数产品代码里，并没有必要这么做，还是以开发效率优先。以我们经常会使用到的计数器实现为例，下面是一个常见的线程安全计数器实现。 </p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">class Counter {
    private final AtomicLong counter = new AtomicLong();
    public void increase() {
        counter.incrementAndGet();
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果利用原始数据类型，可以将其修改为 </p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">class CompactCounter {
    private volatile long counter;
    private static final AtomicLongFieldUpdater<CompactCounter> updater = AtomicLongFieldUpdater.newUpdater(CompactCounter.class, "counter");

    public void increase() {
        updater.incrementAndGet(this);
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ol>
<ol>
<li><p>分析源码</p>
<pre><code> 整体看一下Integer 的职责，它主要包括各种基础的常量，比如最大值、最小值、位数等；前面提到的各种静态工厂方法；获取环境变量数值的方法；各种转换方法，比如     转换为不同进制的字符串，如进制，或者反过来的解析方法等。我们进一步来看一些有意思的地方。
</code></pre><p> 首先，继续深挖缓存， 的缓存范围虽然默认是到，但是在特别的应用场景，比如我们明确知道应用会频繁使用更大的数值，这时候应该怎么办呢？</p>
<p> 缓存上限值实际是可以根据需要调整的， 提供了参数设置：</p>
</li>
</ol>
<blockquote>
<p>-XX:AutoBoxCacheMax=N </p>
</blockquote>
<p>这些实现，都体现在 <a href="http://hg.openjdk.java.net/jdk/jdk/file/26ac622a4cab/src/java.base/share/classes/java/lang/Integer.java" target="_blank" rel="noopener">java.lang.Integer </a>源码之中，并实现在的静态初始化块里。</p>
<p>第二，字符串是不可变的，保证了基本的信息安全和并发编程中的线程安全。如果你去看包装类里存储数值的成员变量，你会发现，不管是 Integer 还是 Boolean 等，都被声明为<code>“private final”</code>，所以，它们同样是不可变类型！</p>
<p>这种设计是可以理解的，或者说是必须的选择。想象一下这个应用场景，比如Integer提供了<code>getInteger()</code> 方法，用于方便地读取系统属性，我们可以用属性来设置服务器某个服务的端口，如果我可以轻易地把获取到的Integer对象改变为其他数值，这会带来产品可靠性方面的严重问题。 </p>
<p>第三， Integer等包装类，定义了类似 SIZE 或者 BYTES 这样的常量，这反映了什么样的设计考虑呢？如其他语言，比如C、 C++，类似整数的位数，其实是不确定的，可能在不同的平台，比如32位或者64位平台，存在非常大的不同。那么，在32位JDK或者64位JDK里，数据位数会有不同吗？或者说，这个问题可以扩展为，我使用32位JDK开发编译的程序，运行在64位JDK上，需要做什么特别的移植工作吗？</p>
<p>其实，这种移植对于Java来说相对要简单些，因为原始数据类型是不存在差异的，这些明确定义在Java语言规范里面，不管是32位还是64位环境，开发者无需担心数据的位数差异。</p>
<p>对于应用移植，虽然存在一些底层实现的差异，比如64位HotSpot JVM里的对象要比32位HotSpot JVM大（具体区别取决于不同JVM实现的选择），但是总体来说，并没有行为差异，应用移植还是可以做到宣称的“一次书写，到处执行”，应用开发者更多需要考虑的是容量、能力等方面的差异。 </p>
<ol>
<li>原始类型线程安全<br>前面提到了线程安全设计，原始数据类型操作是不是线程安全的呢？<br>这里可能存在着不同层面的问题：</li>
</ol>
<ul>
<li>原始数据类型的变量，显然要使用并发相关手段，才能保证线程安全，这些我会在专栏后面的并发主题详细介绍。如果有线程安全的计算需要，建议考虑使用类似、 这样的线程安全类。</li>
<li>特别的是，部分比较宽的数据类型，比如、 ，甚至不能保证更新操作的原子性，可能出现程序读取到只更新了一半数据位的数值！     </li>
</ul>
<ol>
<li><p>原始数据类型和引用类型局限性<br>前面我谈了非常多的技术细节，最后再从平台发展的角度来看看，原始数据类型、对象的局限性和演进。</p>
<p>对于应用开发者，设计复杂而灵活的类型系统似乎已经习以为常了。但是坦白说，毕竟这种类型系统的设计是源于很多年前的技术决定，现在已经逐渐暴露出了一些副作用，例如：</p>
</li>
</ol>
<ul>
<li>原始数据类型和泛型并不能配合使用<br>这是因为的泛型某种程度上可以算作伪泛型，它完全是一种编译期的技巧， 编译期会自动将类型转换为对应的特定类型，这就决定了使用泛型，必须保证相应类型可以转换为Object。</li>
<li>无法高效地表达数据，也不便于表达复杂的数据结构，比如vector和tuple<br>我们知道的对象都是引用类型，如果是一个原始数据类型数组，它在内存里是一段连续的内存，而对象数组则不然，数据存储的是引用，对象往往是分散地存储在堆的不同位置。这种设计虽然带来了极大灵活性，但是也导致了数据操作的低效，尤其是无法充分利用现代 CPU 缓存机制。</li>
</ul>
<p>Java 为对象内建了各种多态、线程安全等方面的支持，但这不是所有场合的需求，尤其是数据处理重要性日益提高，更加高密度的值类型是非常现实的需求。</p>
<h3 id="final、finally、finalize的区别"><a href="#final、finally、finalize的区别" class="headerlink" title="final、finally、finalize的区别"></a>final、finally、finalize的区别</h3><p>final 可以用来修饰类、方法、变量，分别有不同的意义， final修饰的class代表不可以继承扩展， final的变量是不可以修改的，而final的方法也是不可以重写的（override）。</p>
<p>finally 则是Java保证重点代码一定要被执行的一种机制。我们可以使用<code>try-finally</code>或者<code>try-catch-finally</code>来进行类似关闭JDBC连接、保证unlock锁等动作。</p>
<p>finalize 是基础类<code>java.lang.Object</code>的一个方法，它的设计目的是保证对象在被垃圾收集前完成特定资源的回收。 finalize机制现在已经不推荐使用，并且在JDK 9开始被标记为<code>deprecated</code>。 </p>
<p>推荐使用final关键字来明确表示我们代码的语义、逻辑意图，这已经被证明在很多场景下是非常好的实践，比如：</p>
<ul>
<li><p>我们可以将方法或者类声明为final，这样就可以明确告知别人，这些行为是不许修改的。</p>
<p>如果你关注过Java核心类库的定义或源码， 有没有发现 <code>java.lang</code> 包下面的很多类，相当一部分都被声明成为final class？在第三方类库的一些基础类中同样如此，这可以有效避免API使用者更改基础功能，某种程度上，这是保证平台安全的必要手段。</p>
</li>
<li><p>使用final修饰参数或者变量，也可以清楚地避免意外赋值导致的编程错误，甚至，有人明确推荐将所有方法参数、本地变量、成员变量声明成final。</p>
</li>
<li><p>final变量产生了某种程度的不可变（immutable）的效果，所以，可以用于保护只读数据，尤其是在并发编程中，因为明确地不能再赋值final变量，有利于减少额外的同步开销，也可以省去一些防御性拷贝的必要。</p>
</li>
</ul>
<p>final也许会有性能的好处，很多文章或者书籍中都介绍了可在特定场景提高性能，比如，利用final可能有助于JVM将方法进行内联，可以改善编译器进行条件编译的能力等等。坦白说，很多类似的结论都是基于假设得出的，比如现代高性能JVM（如HotSpot）判断内联未必依赖final的提示，要相信JVM还是非常智能的。类似的， final字段对性能的影响，大部分情况下，并没有考虑的必要。</p>
<p>从开发实践的角度，我不想过度强调这一点，这是和JVM的实现很相关的，未经验证比较难以把握。我的建议是，在日常开发中，除非有特别考虑，不然最好不要指望这种小技巧带来的所谓性能好处，程序最好是体现它的语义目的。如果你确实对这方面有兴趣，可以查阅相关资料，我就不再赘述了，不过千万别忘了验证一下。</p>
<p>对于finally，明确知道怎么使用就足够了。需要关闭的连接等资源，更推荐使用Java 7中添加的try-with-resources语句，因为通常Java平台能够更好地处理异常情况，编码量也要少很多，何乐而不为呢。</p>
<p>另外，我注意到有一些常被考到的finally问题（也比较偏门），至少需要了解一下。比如，下面代码会输出什么？ </p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">try {
    // do something
    Sysem.exit(1);
} finally{
    System.out.println(“Print from finally”);
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>上面finally里面的代码可不会被执行的哦，这是一个特例。</p>
<p>对于finalize，我们要明确它是不推荐使用的，业界实践一再证明它不是个好的办法，在Java 9中，甚至明确将Object.finalize()标记为deprecated！如果没有特别的原因，不要实现finalize方法，也不要指望利用它来进行资源回收。</p>
<p>为什么呢？简单说，你无法保证finalize什么时候执行，执行的是否符合预期。使用不当会影响性能，导致程序死锁、挂起等。</p>
<p>通常来说，利用上面的提到的try-with-resources或者try-finally机制，是非常好的回收资源的办法。如果确实需要额外处理，可以考虑Java提供的Cleaner机制或者其他替代方法。接下来，我来介绍更多设计考虑和实践细节。</p>
<p>知识扩展</p>
<ol>
<li><p>注意， final 不是 immutable！<br>在前面介绍了final在实践中的益处，需要注意的是， final 并不等同于 immutable，比如下面这段代码： </p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">final List<String> strList = new ArrayList<>();
strList.add("Hello");
strList.add("world");
List<String> unmodifableStrList = List.of("hello", "world");
unmodifiableStrList.add("again");
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ol>
<p>​    final 只能约束 <code>strList</code> 这个引用不可以被赋值，但是 <code>strList</code> 对象行为不被 <code>final</code> 影响，添加元素等操作是完全正常的。如果我们真的希望对象本身是不可变的，那么需要相应的类支持不可变的行为。在上面这个例子中， <code>List.of</code>方法创建的本身就是不可变 <code>List</code>，最后那句add是会在运行时抛出异常的。</p>
<p>Immutable 在很多场景是非常棒的选择，某种意义上说， Java语言目前并没有原生的不可变支持，如果要实现 immutable 的类，我们需要做到：</p>
<ul>
<li>将 class 自身声明为 <code>final</code> ，这样别人就不能扩展来绕过限制了。</li>
<li>将所有成员变量定义为 private 和 final ，并且不要实现 <code>setter</code> 方法。</li>
<li>通常构造对象时，成员变量使用深度拷贝来初始化，而不是直接赋值，这是一种防御措施，因为你无法确定输入对象不被其他人修改。</li>
<li><p>如果确实需要实现 <code>getter</code> 方法，或者其他可能会返回内部状态的方法，使用 <code>copy-on-write</code> 原则，创建私有的copy。</p>
<p>这些原则是不是在并发编程实践中经常被提到？的确如此。</p>
<p>关于setter/getter方法，很多人喜欢直接用IDE一次全部生成，建议最好是你确定有需要时再实现。</p>
</li>
</ul>
<ol>
<li><p>finalize真的那么不堪？<br> 前面简单介绍了finalize是一种已经被业界证明了的非常不好的实践，那么为什么会导致那些问题呢？</p>
<p> finalize的执行是和垃圾收集关联在一起的，一旦实现了非空的finalize方法，就会导致相应对象回收呈现数量级上的变慢，有人专门做过benchmark，大概是40~50倍的下降。</p>
<p> 因为， finalize 被设计成在对象被垃圾收集前调用，这就意味着实现了 <code>finalize</code> 方法的对象是个“特殊公民”， JVM要对它进行额外处理。 finalize 本质上成为了快速回收的阻碍者，可能导致你的对象经过多个垃圾收集周期才能被回收。</p>
<p> 有人也许会问，我用 <code>System.runFinalization()</code> 告诉JVM积极一点，是不是就可以了？也许有点用，但是问题在于，这还是不可预测、不能保证的，所以本质上还是不能指望。实践中，因为 finalize 拖慢垃圾收集，导致大量对象堆积，也是一种典型的导致 OOM 的原因。</p>
<p> 从另一个角度，我们要确保回收资源就是因为资源都是有限的，垃圾收集时间的不可预测，可能会极大加剧资源占用。这意味着对于消耗非常高频的资源，千万不要指望finalize去承担资源释放的主要职责，最多让finalize作为最后的“守门员”，况且它已经暴露了如此多的问题。这也是为什么我推荐， 资源用完即显式释放，或者利用资源池来尽量重用。</p>
<p> finalize还会掩盖资源回收时的出错信息，我们看下面一段JDK的源代码，截取 <code>java.lang.ref.Finalizer</code></p>
</li>
</ol>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">private void runFinalizer(JavaLangAccess jla) {
// ... 省略部分代码
try {
    Object finalizee = this.get();
    if (finalizee != null && !(finalizee insanceof java.lang.Enum)) {
        jla.invokeFinalize(finalizee);
        // Clear sack slot containing this variable, to decrease
        // the chances of false retention with a conservative GC
        finalizee = null;
    }
} catch (Throwable x) { }
    super.clear();
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这里的 Throwable 是被生吞了的！ 也就意味着一旦出现异常或者出错，你得不到任何有效信息。况且， Java在 finalize 阶段也没有好的方式处理任何信息，不然更加不可预测。</p>
<ol>
<li><p>有什么机制可以替换 finalize 吗？<br>Java平台目前在逐步使用<code>java.lang.ref.Cleaner</code> 来替换掉原有的<code>finalize</code>实现。 Cleaner的实现利用了<em>幻象引用（PhantomReference）</em>，这是一种常见的所谓 <em>post-mortem</em> 清理机制。利用幻象引用和引用队列，我们可以保证对象被彻底销毁前做一些类似资源回收的工作，比如关闭文件描述符（操作系统有限的资源），它比finalize更加轻量、更加可靠。</p>
<p>吸取了 finalize 里的教训，每个 Cleaner 的操作都是独立的，它有自己的运行线程，所以可以避免意外死锁等问题。</p>
<p>实践中，我们可以为自己的模块构建一个 Cleaner，然后实现相应的清理逻辑。下面是JDK自身提供的样例程序： </p>
</li>
</ol>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">public class CleaningExample implements AutoCloseable {
    // A cleaner, preferably one shared within a library
    private static final Cleaner cleaner = <cleaner>;
    static class State implements Runnable {
        State(...) {
        // initialize State needed for cleaning action
        }
        public void run() {
            // cleanup action accessing State, executed at most once
        }
    }
    private final State;
    private final Cleaner.Cleanable cleanable
    public CleaningExample() {
        this.sate = new State(...);
        this.cleanable = cleaner.regiser(this, sate);
    }
    public void close() {
        cleanable.clean();
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>注意，从可预测性的角度来判断， Cleaner或者幻象引用改善的程度仍然是有限的，如果由于种种原因导致幻象引用堆积，同样会出现问题。所以， Cleaner适合作为一种最后的保证手段，而不是完全依赖Cleaner进行资源回收，不然我们就要再做一遍finalize的噩梦了。</p>
<p>我也注意到很多第三方库自己直接利用幻象引用定制资源收集，比如广泛使用的MySQL JDBC driver之一的 <em>mysql-connector-j</em>，就利用了幻象引用机制。幻象引用也可以进行类似链条式依赖关系的动作，比如，进行总量控制的场景，保证只有连接被关闭，相应资源被回收，连接池才能创建新的连接。</p>
<p>另外，这种代码如果稍有不慎添加了对资源的强引用关系，就会导致循环引用关系，前面提到的MySQL JDBC就在特定模式下有这种问题，导致内存泄漏。上面的示例代码中，将State定义为static，就是为了避免普通的内部类隐含着对外部对象的强引用，因为那样会使外部对象无法进入幻象可达的状态。</p>
<h3 id="重载和重写的区别"><a href="#重载和重写的区别" class="headerlink" title="重载和重写的区别"></a>重载和重写的区别</h3><h3 id="抽象类和接口的区别"><a href="#抽象类和接口的区别" class="headerlink" title="抽象类和接口的区别"></a>抽象类和接口的区别</h3><p>抽象类：只可以单继承，可以有自己的实现</p>
<p>接口：可以多继承，<code>jdk8</code>之后新版本中可可以有自己的默认实现</p>
<ol>
<li>支持多重继承：接口支持；抽象类不支持；类不支持；</li>
<li>支持抽象函数：接口语义上支持；抽象类支持；类不支持；</li>
<li>允许函数实现：接口不允许；抽象类支持；类允许；</li>
<li>允许实例化：接口不允许；抽象类不允许；类允许；</li>
<li>允许部分函数实现：接口不允许；抽象类允许；类不允许。</li>
<li>定义的内容：接口中只能包括public函数以及public static final常量；抽象类与类均无任何限制。</li>
<li>使用时机：当想要支持多重继承，或是为了定义一种类型请使用接口；当打算提供带有部分实现的“模板”类，而将一些功能需要延迟实现请使用抽象类；当你打算提供完整的具体实现请使用类。 </li>
</ol>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">public interface Collection<E> extends Iterable<E> {
    /**
    * Returns a sequential Stream with this collection as its source
    * ...
    **/
    default Stream<E> sream() {
        return StreamSupport.stream(spliterator(), false);
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>面向对象方面考虑，抽象是对拥有同本质对象的抽取，例如衣服，接口是对对象具有的共同特征提取，例如衣服上的口袋。</p>
<p>接口是对行为的抽象，它是抽象方法的集合，利用接口可以达到API定义和实现分离的目的。接口，不能实例化；不能包含任何非常量成员，任何field都是隐含着<code>public</code> <code>static</code> <code>final</code>的意义；同时，没有非静态方法实现，也就是说要么是抽象方法，要么是静态方法。 Java标准类库中，定义了非常多的接口，比如<code>java.util.List</code>。 </p>
<p>抽象类是不能实例化的类，用abstract关键字修饰class，其目的主要是代码重用。除了不能实例化，形式上和一般的Java类并没有太大区别，可以有一个或者多个抽象方法，也可以没有抽象方法。抽象类大多用于抽取相关Java类的共用方法实现或者是共同成员变量，然后通过继承的方式达到代码复用的目的。 Java标准库中，比如collection框架，很多通用部分就被抽取成为抽象类，例如<code>java.util.AbstractList</code>。</p>
<h3 id="自定义注解的场景和实现"><a href="#自定义注解的场景和实现" class="headerlink" title="自定义注解的场景和实现"></a>自定义注解的场景和实现</h3><p>自定义注解使用场景</p>
<ol>
<li>类属性自动赋值。</li>
<li>验证对象属性完整性。</li>
<li>代替配置文件功能，像spring基于注解的配置。</li>
<li>可以生成文档，像java代码注释中的@see,@param等</li>
</ol>
<h3 id="反射的用途和实现"><a href="#反射的用途和实现" class="headerlink" title="反射的用途和实现"></a>反射的用途和实现</h3><blockquote>
<p><a href="https://www.sczyh30.com/posts/Java/java-reflection-1/" target="_blank" rel="noopener">https://www.sczyh30.com/posts/Java/java-reflection-1/</a></p>
</blockquote>
<h4 id="一"><a href="#一" class="headerlink" title="一"></a>一</h4><p>当程序运行时，允许改变程序结构或变量类型，这种语言称为动态语言。我们认为 Java 并不是动态语言，但是它却又一个非常突出的动态相关的机制，即：反射。</p>
<p>Reflection  是Java 程序开发语言的特征之一，它允许运行中的 Java 程序获取自身的信息，并且可以操作类和对象的内部属性。</p>
<p>通过反射，我们可以在运行时获得程序或程序集中每一个类型成员和成员变量的信息。<br>程序中一般的对象类型都是在编译期就确定下来的，而Java 反射机制可以动态的创建对象并调用其属性，这样对象的类型在编译期是未知的。所以我们可以通过反射机制直接创建对象即使这个对象在编译期是未知的。<br>反射的核心：是 JVM 在运行时 才动态加载的类或调用方法或属性，他不需要事先（写代码的时候或编译期）知道运行对象是谁。</p>
<p>Java 反射主要提供以下功能：</p>
<ul>
<li>在运行时判断任意一个对象所属的类；</li>
<li>在运行时构造任意一个类的对象；</li>
<li>在运行时判断任意一个类所具有的成员变量和方法（通过反射甚至可以调用private方法）；</li>
<li>在运行时调用任意一个对象的方法</li>
</ul>
<p>重点：<strong>是运行时而不是编译时</strong></p>
<h4 id="二、反射的主要用途"><a href="#二、反射的主要用途" class="headerlink" title="二、反射的主要用途"></a>二、反射的主要用途</h4><p>很多人都认为反射在实际的 Java 开发应用中并不广泛，其实不然。当我们在使用 IDE(如 Eclipse，IDEA)时，当我们输入一个对象或类并想调用它的属性或方法时，一按点号，编译器就会自动列出它的属性或方法，这里就会用到反射。</p>
<p><strong>反射最重要的用途就是开发各种通用框架。</strong>很多框架（比如 Spring）都是配置化的（比如通过 XML 文件配置 Bean），为了保证框架的通用性，它们可能需要根据配置文件加载不同的对象或类，调用不同的方法，这个时候就必须用到反射，运行时动态加载需要加载的对象。</p>
<p>举一个例子，在运用 Struts 2 框架的开发中我们一般会在 <code>struts.xml</code> 里去配置 <code>Action</code>，比如：</p>
<pre class="line-numbers language-lang-xml"><code class="language-lang-xml"><action name="login" class="com.lie.test.action.SimpleLoginAction" method="execute">
    <result>/shop/shop-index.jsp</result>
    <result name="error">login.jsp</result>       
</action>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>配置文件与 <code>Action</code> 建立了一种映射关系，当 View 层发出请求时，请求会被 <code>StrutsPrepareAndExecuteFilter</code> 拦截，然后 <code>StrutsPrepareAndExecuteFilter</code> 会去动态地创建 Action 实例。比如我们请求 <code>login.action</code>，那么 <code>StrutsPrepareAndExecuteFilter</code>就会去解析 struts.xml 文件，检索action 中 name 为login的 Action，并根据 class 属性创建 SimpleLoginAction 实例，并用 invoke 方法来调用execute 方法，这个过程离不开反射。</p>
<p>对与框架开发人员来说，反射虽小但作用非常大，它是各种容器实现的核心。而对于一般的开发者来说，不深入框架开发则用反射用的就会少一点，不过了解一下框架的底层机制有助于丰富自己的编程思想，也是很有益的。</p>
<h4 id="三、反射的基本运用"><a href="#三、反射的基本运用" class="headerlink" title="三、反射的基本运用"></a>三、反射的基本运用</h4><p>上面我们提到了反射可以用于判断任意对象所属的类，获得 Class 对象，构造任意一个对象以及调用一个对象。这里我们介绍一下基本反射功能的使用和实现(反射相关的类一般都在 java.lang.relfect 包里)。</p>
<h5 id="1、获得-Class-对象"><a href="#1、获得-Class-对象" class="headerlink" title="1、获得 Class 对象"></a>1、获得 Class 对象</h5><p>方法有三种：</p>
<p>(1) 使用 Class 类的 <code>forName</code> 静态方法:</p>
<pre class="line-numbers language-lang-Java"><code class="language-lang-Java"> public static Class<?> forName(String className)
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>比如在 JDBC 开发中常用此方法加载数据库驱动:</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java"> Class.forName(driver);
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>(2)直接获取某一个对象的 class，比如:</p>
<pre class="line-numbers language-lang-Java"><code class="language-lang-Java">Class<?> klass = int.class;
Class<?> classInt = Integer.TYPE;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>(3)调用某个对象的 <code>getClass()</code> 方法，比如:</p>
<pre class="line-numbers language-lang-Java"><code class="language-lang-Java">StringBuilder str = new StringBuilder("123");
Class<?> klass = str.getClass();
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h5 id="2、判断是否为某个类的实例"><a href="#2、判断是否为某个类的实例" class="headerlink" title="2、判断是否为某个类的实例"></a>2、判断是否为某个类的实例</h5><p>一般地，我们用 <code>instanceof</code> 关键字来判断是否为某个类的实例。同时我们也可以借助反射中 Class 对象的 <code>isInstance()</code> 方法来判断是否为某个类的实例，它是一个 native 方法：</p>
<pre class="line-numbers language-lang-Java"><code class="language-lang-Java">public native boolean isInstance(Object obj);
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h5 id="3、创建实例"><a href="#3、创建实例" class="headerlink" title="3、创建实例"></a>3、创建实例</h5><p>通过反射来生成对象主要有两种方式。</p>
<ul>
<li>使用Class对象的<code>newInstance()</code>方法来创建Class对象对应类的实例。</li>
</ul>
<pre class="line-numbers language-lang-Java"><code class="language-lang-Java">Class<?> c = String.class;Object str = c.newInstance();
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<ul>
<li>先通过Class对象获取指定的Constructor对象，再调用Constructor对象的<code>newInstance()</code>方法来创建实例。这种方法可以用指定的构造器构造类的实例。</li>
</ul>
<pre class="line-numbers language-lang-Java"><code class="language-lang-Java">//获取String所对应的Class对象
Class<?> c = String.class;
//获取String类带一个String参数的构造器
Constructor constructor = c.getConstructor(String.class);
//根据构造器创建实例
Object obj = constructor.newInstance("23333");System.out.println(obj);
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h5 id="4、获取方法"><a href="#4、获取方法" class="headerlink" title="4、获取方法"></a>4、获取方法</h5><p>获取某个Class对象的方法集合，主要有以下几个方法：</p>
<ul>
<li><code>getDeclaredMethods</code> 方法返回类或接口声明的所有方法，包括公共、保护、默认（包）访问和私有方法，但不包括继承的方法。</li>
</ul>
<pre class="line-numbers language-lang-Java"><code class="language-lang-Java">public Method[] getDeclaredMethods() throws SecurityException
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<ul>
<li><code>getMethods</code> 方法返回某个类的所有公用（public）方法，包括其继承类的公用方法。</li>
</ul>
<pre class="line-numbers language-lang-Java"><code class="language-lang-Java">public Method[] getMethods() throws SecurityException
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<ul>
<li><code>getMethod</code> 方法返回一个特定的方法，其中第一个参数为方法名称，后面的参数为方法的参数对应Class的对象。</li>
</ul>
<pre class="line-numbers language-lang-Java"><code class="language-lang-Java">public Method getMethod(String name, Class<?>... parameterTypes)
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>只是这样描述的话可能难以理解，我们用例子来理解这三个方法：</p>
<pre class="line-numbers language-lang-Java"><code class="language-lang-Java">package com.lie.common;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
public class test1 {
    public static void test() throws IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException {
        Class<?> c = methodClass.class;
        Object object = c.newInstance();
        Method[] methods = c.getMethods();
        Method[] declaredMethods = c.getDeclaredMethods();
        //获取methodClass类的add方法
        Method method = c.getMethod("add", int.class, int.class);
        //getMethods()方法获取的所有方法
        System.out.println("getMethods获取的方法：");
        for(Method m:methods){
            System.out.println(m);
        }
        //getDeclaredMethods()方法获取的所有方法
        System.out.println("getDeclaredMethods获取的方法：");
        for(Method m:declaredMethods){
            System.out.println(m);
        }
    }
}
class methodClass {
    public final int fuck = 3;
    public int add(int a,int b) {
        return a+b;
    }
    public int sub(int a,int b) {
        return a+b;
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>程序运行的结果如下:</p>
<pre class="line-numbers language-lang-Java"><code class="language-lang-Java">getMethods获取的方法：
public int com.lie.common.methodClass.add(int,int)
    public int com.lie.common.methodClass.sub(int,int)
    public final void java.lang.Object.wait() throws java.lang.InterruptedExceptionpublic
    final void java.lang.Object.wait(long,int) throws java.lang.InterruptedExceptionpublic 
    final native void java.lang.Object.wait(long) throws java.lang.InterruptedExceptionpublic 
    boolean java.lang.Object.equals(java.lang.Object)
    public java.lang.String java.lang.Object.toString()
    public native int java.lang.Object.hashCode()
    public final native java.lang.Class java.lang.Object.getClass()
    public final native void java.lang.Object.notify()
    public final native void java.lang.Object.notifyAll()
    getDeclaredMethods获取的方法：
    public int com.lie.common.methodClass.add(int,int)
    public int com.lie.common.methodClass.sub(int,int)
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以看到，通过 <code>getMethods()</code> 获取的方法可以获取到父类的方法,比如 java.lang.Object 下定义的各个方法。</p>
<h5 id="5、获取构造器信息"><a href="#5、获取构造器信息" class="headerlink" title="5、获取构造器信息"></a>5、获取构造器信息</h5><p>获取类构造器的用法与上述获取方法的用法类似。主要是通过Class类的getConstructor方法得到Constructor类的一个实例，而Constructor类有一个newInstance方法可以创建一个对象实例:</p>
<pre class="line-numbers language-lang-Java"><code class="language-lang-Java">public T newInstance(Object ... initargs)
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>此方法可以根据传入的参数来调用对应的Constructor创建对象实例。</p>
<h5 id="6、获取类的成员变量（字段）信息"><a href="#6、获取类的成员变量（字段）信息" class="headerlink" title="6、获取类的成员变量（字段）信息"></a>6、获取类的成员变量（字段）信息</h5><p>主要是这几个方法，在此不再赘述：</p>
<ul>
<li><code>getFiled</code>：访问公有的成员变量</li>
<li><code>getDeclaredField</code>：所有已声明的成员变量，但不能得到其父类的成员变量</li>
</ul>
<p><code>getFileds</code> 和 <code>getDeclaredFields</code> 方法用法同上（参照 Method）。</p>
<h5 id="7、调用方法"><a href="#7、调用方法" class="headerlink" title="7、调用方法"></a>7、调用方法</h5><p>当我们从类中获取了一个方法后，我们就可以用 <code>invoke()</code> 方法来调用这个方法。<code>invoke</code> 方法的原型为:</p>
<pre class="line-numbers language-lang-Java"><code class="language-lang-Java">public Object invoke(Object obj, Object... args) throws IllegalAccessException, IllegalArgumentException, InvocationTargetException
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>下面是一个实例：</p>
<pre class="line-numbers language-lang-Java"><code class="language-lang-Java">public class test1 {
    public static void main(String[] args) throws IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException {
        Class<?> klass = methodClass.class;
        //创建methodClass的实例
        Object obj = klass.newInstance();
        //获取methodClass类的add方法
        Method method = klass.getMethod("add",int.class,int.class);
        //调用method对应的方法 => add(1,4)
        Object result = method.invoke(obj,1,4);
        System.out.println(result);
    }
}
class methodClass {
    public final int fuck = 3;
    public int add(int a,int b) {
        return a+b;
    }
    public int sub(int a,int b) {
        return a+b;
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>关于 <code>invoke</code> 方法的详解，后面我会专门写一篇文章来深入解析 invoke 的过程。</p>
<h5 id="8、利用反射创建数组"><a href="#8、利用反射创建数组" class="headerlink" title="8、利用反射创建数组"></a>8、利用反射创建数组</h5><p>数组在Java里是比较特殊的一种类型，它可以赋值给一个Object Reference。下面我们看一看利用反射创建数组的例子：</p>
<pre class="line-numbers language-lang-Java"><code class="language-lang-Java">public static void testArray() throws ClassNotFoundException {
    Class<?> cls = Class.forName("java.lang.String");
    Object array = Array.newInstance(cls,25);
    //往数组里添加内容
    Array.set(array,0,"hello");
    Array.set(array,1,"Java");
    Array.set(array,2,"fuck");
    Array.set(array,3,"Scala");
    Array.set(array,4,"Clojure");
    //获取某一项的内容
    System.out.println(Array.get(array,3));
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>其中的Array类为java.lang.reflect.Array类。我们通过Array.newInstance()创建数组对象，它的原型是:</p>
<pre class="line-numbers language-lang-Java"><code class="language-lang-Java">public static Object newInstance(Class<?> componentType, int length) throws NegativeArraySizeException {
    return newArray(componentType, length);
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>而 <code>newArray</code> 方法是一个 native 方法，它在 HotSpot JVM 里的具体实现我们后边再研究，这里先把源码贴出来：</p>
<pre class="line-numbers language-lang-Java"><code class="language-lang-Java">private static native Object newArray(Class<?> componentType, int length) throws NegativeArraySizeException;
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>源码目录：<code>openjdk\hotspot\src\share\vm\runtime\reflection.cpp</code></p>
<pre class="line-numbers language-lang-Java"><code class="language-lang-Java">arrayOop Reflection::reflect_new_array(oop element_mirror, jint length, TRAPS) {
    if (element_mirror == NULL) {
        THROW_0(vmSymbols::java_lang_NullPointerException());
    }
    if (length < 0) {
        THROW_0(vmSymbols::java_lang_NegativeArraySizeException());
    }  
    if (java_lang_Class::is_primitive(element_mirror)) {
        Klass* tak = basic_type_mirror_to_arrayklass(element_mirror, CHECK_NULL); 
        return TypeArrayKlass::cast(tak)->allocate(length, THREAD);
    } else {
        Klass* k = java_lang_Class::as_Klass(element_mirror);
        if (k->oop_is_array() && ArrayKlass::cast(k)->dimension() >= MAX_DIM) {
            THROW_0(vmSymbols::java_lang_IllegalArgumentException());
        } 
        return oopFactory::new_objArray(k, length, THREAD);
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>另外，Array 类的 <code>set</code> 和 <code>get</code> 方法都为 native 方法，在 HotSpot JVM 里分别对应 <code>Reflection::array_set</code> 和 <code>Reflection::array_get</code> 方法，这里就不详细解析了。</p>
<h4 id="四、反射的一些注意事项"><a href="#四、反射的一些注意事项" class="headerlink" title="四、反射的一些注意事项"></a>四、反射的一些注意事项</h4><p>由于反射会额外消耗一定的系统资源，因此如果不需要动态地创建一个对象，那么就不需要用反射。</p>
<p>另外，反射调用方法时可以忽略权限检查，因此可能会破坏封装性而导致安全问题。</p>
<h4 id="invoke-方法"><a href="#invoke-方法" class="headerlink" title="invoke 方法"></a>invoke 方法</h4><p>即使没有学过反射，大家也一定会见过invoke方法。因为很多方法调用都是靠invoke方法，所以很多异常的抛出都会定位到invoke方法，比如下面的情形大家会很熟悉:</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">java.lang.NullPointerException  at ......  at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)  at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)  at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)  at java.lang.reflect.Method.invoke(Method.java:497)
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>大家在看到异常抛出时，除了想要排除Bug，是不是同时也对这个神秘的invoke乃至invoke0方法有一些好奇呢？我们下面就来揭开它神秘的面纱，探寻底层的机制。</p>
<h4 id="浅析invoke过程"><a href="#浅析invoke过程" class="headerlink" title="浅析invoke过程"></a>浅析invoke过程</h4><p>上一篇文章我们讲过，invoke方法用来在运行时动态地调用某个实例的方法。它的实现如下：</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">@CallerSensitive
public Object invoke(Object obj, Object... args)
    throws IllegalAccessException, IllegalArgumentException,
       InvocationTargetException
{
    if (!override) {
        if (!Reflection.quickCheckMemberAccess(clazz, modifiers)) {
            Class<?> caller = Reflection.getCallerClass();
            checkAccess(caller, clazz, obj, modifiers);
        }
    }
    MethodAccessor ma = methodAccessor;             // read volatile
    if (ma == null) {
        ma = acquireMethodAccessor();
    }
    return ma.invoke(obj, args);
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们根据invoke方法的实现，将其分为以下几步：</p>
<h5 id="1、权限检查"><a href="#1、权限检查" class="headerlink" title="1、权限检查"></a>1、权限检查</h5><p>invoke方法会首先检查AccessibleObject的override属性的值。AccessibleObject 类是 Field、Method 和 Constructor 对象的基类。它提供了将反射的对象标记为在使用时取消默认 Java 语言访问控制检查的能力。<br>override的值默认是false,表示需要权限调用规则，调用方法时需要检查权限;我们也可以用setAccessible方法设置为true,若override的值为true，表示忽略权限规则，调用方法时无需检查权限（也就是说可以调用任意的private方法，违反了封装）。<br>如果override属性为默认值false，则进行进一步的权限检查：<br>（1）首先用Reflection.quickCheckMemberAccess(clazz, modifiers)方法检查方法是否为public，如果是的话跳出本步；如果不是public方法，那么用Reflection.getCallerClass()方法获取调用这个方法的Class对象，这是一个native方法:</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">@CallerSensitive    
public static native Class<?> getCallerClass();
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>在OpenJDK的源码中找到此方法的JNI入口(Reflection.c):</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">JNIEXPORT jclass JNICALL Java_sun_reflect_Reflection_getCallerClass__(JNIEnv *env, jclass unused){
    return JVM_GetCallerClass(env, JVM_CALLER_DEPTH);
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>其中JVM_GetCallerClass的源码如下，有兴趣的可以研究一下(位于jvm.cpp):</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">JVM_ENTRY(jclass, JVM_GetCallerClass(JNIEnv* env, int depth))
  JVMWrapper("JVM_GetCallerClass");
  // Pre-JDK 8 and early builds of JDK 8 don't have a CallerSensitive annotation; or
  // sun.reflect.Reflection.getCallerClass with a depth parameter is provided
  // temporarily for existing code to use until a replacement API is defined.
  if (SystemDictionary::reflect_CallerSensitive_klass() == NULL || depth != JVM_CALLER_DEPTH) {
    Klass* k = thread->security_get_caller_class(depth);
    return (k == NULL) ? NULL : (jclass) JNIHandles::make_local(env, k->java_mirror());
  }
  // Getting the class of the caller frame.
  //
  // The call stack at this point looks something like this:
  //
  // [0] [ @CallerSensitive public sun.reflect.Reflection.getCallerClass ]
  // [1] [ @CallerSensitive API.method                                   ]
  // [.] [ (skipped intermediate frames)                                 ]
  // [n] [ caller                                                        ]
  vframeStream vfst(thread);
  // Cf. LibraryCallKit::inline_native_Reflection_getCallerClass
  for (int n = 0; !vfst.at_end(); vfst.security_next(), n++) {
    Method* m = vfst.method();
    assert(m != NULL, "sanity");
    switch (n) {
    case 0:
      // This must only be called from Reflection.getCallerClass
      if (m->intrinsic_id() != vmIntrinsics::_getCallerClass) {
        THROW_MSG_NULL(vmSymbols::java_lang_InternalError(), "JVM_GetCallerClass must only be called from Reflection.getCallerClass");
      }
      // fall-through
    case 1:
      // Frame 0 and 1 must be caller sensitive.
      if (!m->caller_sensitive()) {
        THROW_MSG_NULL(vmSymbols::java_lang_InternalError(), err_msg("CallerSensitive annotation expected at frame %d", n));
      }
      break;
    default:
      if (!m->is_ignored_by_security_stack_walk()) {
        // We have reached the desired frame; return the holder class.
        return (jclass) JNIHandles::make_local(env, m->method_holder()->java_mirror());
      }
      break;
    }
  }
  return NULL;
JVM_END
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>获取了这个Class对象caller后用checkAccess方法做一次快速的权限校验，其实现为:</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">volatile Object securityCheckCache;
    void checkAccess(Class<?> caller, Class<?> clazz, Object obj, int modifiers)
        throws IllegalAccessException {
        if (caller == clazz) {  // 快速校验
            return;             // 权限通过校验
        }
        Object cache = securityCheckCache;  // read volatile
        Class<?> targetClass = clazz;
        if (obj != null
            && Modifier.isProtected(modifiers)
            && ((targetClass = obj.getClass()) != clazz)) {
            // Must match a 2-list of { caller, targetClass }.
            if (cache instanceof Class[]) {
                Class<?>[] cache2 = (Class<?>[]) cache;
                if (cache2[1] == targetClass &&
                    cache2[0] == caller) {
                    return;     // ACCESS IS OK
                }
                // (Test cache[1] first since range check for [1]
                // subsumes range check for [0].)
            }
        } else if (cache == caller) {
            // Non-protected case (or obj.class == this.clazz).
            return;             // ACCESS IS OK
        }
        // If no return, fall through to the slow path.
        slowCheckMemberAccess(caller, clazz, obj, modifiers, targetClass);
    }
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>首先先执行一次快速校验，一旦调用方法的Class正确则权限检查通过。<br>若未通过，则创建一个缓存，中间再进行一堆检查（比如检验是否为protected属性）。<br>如果上面的所有权限检查都未通过，那么将执行更详细的检查，其实现为：</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">// Keep all this slow stuff out of line:
void slowCheckMemberAccess(Class<?> caller, Class<?> clazz, Object obj, int modifiers,
                           Class<?> targetClass)
    throws IllegalAccessException
{
    Reflection.ensureMemberAccess(caller, clazz, obj, modifiers);
    // Success: Update the cache.
    Object cache = ((targetClass == clazz)
                    ? caller
                    : new Class<?>[] { caller, targetClass });
    // Note:  The two cache elements are not volatile,
    // but they are effectively final.  The Java memory model
    // guarantees that the initializing stores for the cache
    // elements will occur before the volatile write.
    securityCheckCache = cache;         // write volatile
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>大体意思就是，用Reflection.ensureMemberAccess方法继续检查权限，若检查通过就更新缓存，这样下一次同一个类调用同一个方法时就不用执行权限检查了，这是一种简单的缓存机制。由于JMM的happens-before规则能够保证缓存初始化能够在写缓存之前发生，因此两个cache不需要声明为volatile。<br>到这里，前期的权限检查工作就结束了。如果没有通过检查则会抛出异常，如果通过了检查则会到下一步。</p>
<h5 id="2、调用MethodAccessor的invoke方法"><a href="#2、调用MethodAccessor的invoke方法" class="headerlink" title="2、调用MethodAccessor的invoke方法"></a>2、调用MethodAccessor的invoke方法</h5><p>Method.invoke()实际上并不是自己实现的反射调用逻辑，而是委托给sun.reflect.MethodAccessor来处理。<br>首先要了解Method对象的基本构成，每个Java方法有且只有一个Method对象作为root，它相当于根对象，对用户不可见。当我们创建Method对象时，我们代码中获得的Method对象都相当于它的副本（或引用）。root对象持有一个MethodAccessor对象，所以所有获取到的Method对象都共享这一个MethodAccessor对象，因此必须保证它在内存中的可见性。root对象其声明及注释为：</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">private volatile MethodAccessor methodAccessor;
// For sharing of MethodAccessors. This branching structure is
// currently only two levels deep (i.e., one root Method and
// potentially many Method objects pointing to it.)
//
// If this branching structure would ever contain cycles, deadlocks can
// occur in annotation code.
private Method  root;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>那么MethodAccessor到底是个啥玩意呢？</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">/** This interface provides the declaration for
    java.lang.reflect.Method.invoke(). Each Method object is
    configured with a (possibly dynamically-generated) class which
    implements this interface.
*/
    public interface MethodAccessor {
    /** Matches specification in {@link java.lang.reflect.Method} */
    public Object invoke(Object obj, Object[] args)
        throws IllegalArgumentException, InvocationTargetException;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以看到MethodAccessor是一个接口，定义了invoke方法。分析其Usage可得它的具体实现类有:</p>
<ul>
<li>sun.reflect.DelegatingMethodAccessorImpl</li>
<li>sun.reflect.MethodAccessorImpl</li>
<li>sun.reflect.NativeMethodAccessorImpl</li>
</ul>
<p>第一次调用一个Java方法对应的Method对象的invoke()方法之前，实现调用逻辑的MethodAccessor对象还没有创建；等第一次调用时才新创建MethodAccessor并更新给root，然后调用MethodAccessor.invoke()完成反射调用：</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">// NOTE that there is no synchronization used here. It is correct
// (though not efficient) to generate more than one MethodAccessor
// for a given Method. However, avoiding synchronization will
// probably make the implementation more scalable.
private MethodAccessor acquireMethodAccessor() {
    // First check to see if one has been created yet, and take it
    // if so
    MethodAccessor tmp = null;
    if (root != null) tmp = root.getMethodAccessor();
    if (tmp != null) {
        methodAccessor = tmp;
    } else {
        // Otherwise fabricate one and propagate it up to the root
        tmp = reflectionFactory.newMethodAccessor(this);
        setMethodAccessor(tmp);
    }
    return tmp;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以看到methodAccessor实例由reflectionFactory对象操控生成，它在AccessibleObject下的声明如下:</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">// Reflection factory used by subclasses for creating field,
// method, and constructor accessors. Note that this is called
// very early in the bootstrapping process.
static final ReflectionFactory reflectionFactory = AccessController.doPrivileged(        new sun.reflect.ReflectionFactory.GetReflectionFactoryAction());
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>再研究一下sun.reflect.ReflectionFactory类的源码：</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">public class ReflectionFactory {
    private static boolean initted = false;
    private static Permission reflectionFactoryAccessPerm
        = new RuntimePermission("reflectionFactoryAccess");
    private static ReflectionFactory soleInstance = new ReflectionFactory();
    // Provides access to package-private mechanisms in java.lang.reflect
    private static volatile LangReflectAccess langReflectAccess;
    // 这里设计得非常巧妙
    // "Inflation" mechanism. Loading bytecodes to implement
    // Method.invoke() and Constructor.newInstance() currently costs
    // 3-4x more than an invocation via native code for the first
    // invocation (though subsequent invocations have been benchmarked
    // to be over 20x faster). Unfortunately this cost increases
    // startup time for certain applications that use reflection
    // intensively (but only once per class) to bootstrap themselves.
    // To avoid this penalty we reuse the existing JVM entry points
    // for the first few invocations of Methods and Constructors and
    // then switch to the bytecode-based implementations.
    //
    // Package-private to be accessible to NativeMethodAccessorImpl
    // and NativeConstructorAccessorImpl
    private static boolean noInflation        = false;
    private static int     inflationThreshold = 15;
    //......
    //这是生成MethodAccessor的方法
    public MethodAccessor newMethodAccessor(Method method) {
        checkInitted();
        if (noInflation && !ReflectUtil.isVMAnonymousClass(method.getDeclaringClass())) {
            return new MethodAccessorGenerator().
                generateMethod(method.getDeclaringClass(),
                               method.getName(),
                               method.getParameterTypes(),
                               method.getReturnType(),
                               method.getExceptionTypes(),
                               method.getModifiers());
        } else {
            NativeMethodAccessorImpl acc =
                new NativeMethodAccessorImpl(method);
            DelegatingMethodAccessorImpl res =
                new DelegatingMethodAccessorImpl(acc);
            acc.setParent(res);
            return res;
        }
    }
    //......
    /** We have to defer full initialization of this class until after
    the static initializer is run since java.lang.reflect.Method's
    static initializer (more properly, that for
    java.lang.reflect.AccessibleObject) causes this class's to be
    run, before the system properties are set up. */
    private static void checkInitted() {
        if (initted) return;
        AccessController.doPrivileged(
            new PrivilegedAction<Void>() {
                public Void run() {
                    // Tests to ensure the system properties table is fully
                    // initialized. This is needed because reflection code is
                    // called very early in the initialization process (before
                    // command-line arguments have been parsed and therefore
                    // these user-settable properties installed.) We assume that
                    // if System.out is non-null then the System class has been
                    // fully initialized and that the bulk of the startup code
                    // has been run.
                    if (System.out == null) {
                        // java.lang.System not yet fully initialized
                        return null;
                    }
                    String val = System.getProperty("sun.reflect.noInflation");
                    if (val != null && val.equals("true")) {
                        noInflation = true;
                    }
                    val = System.getProperty("sun.reflect.inflationThreshold");
                    if (val != null) {
                        try {
                            inflationThreshold = Integer.parseInt(val);
                        } catch (NumberFormatException e) {
                            throw new RuntimeException("Unable to parse property sun.reflect.inflationThreshold", e);
                        }
                    }
                    initted = true;
                    return null;
                }
            });
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>观察前面的声明部分的注释，我们可以发现一些有趣的东西。就像注释里说的，实际的MethodAccessor实现有两个版本，一个是Java版本，一个是native版本，两者各有特点。初次启动时 <code>Method.invoke()</code> 和 <code>Constructor.newInstance()</code> 方法采用native方法要比Java方法快3-4倍，而启动后native方法又要消耗额外的性能而慢于Java方法。也就是说，Java实现的版本在初始化时需要较多时间，但长久来说性能较好；native版本正好相反，启动时相对较快，但运行时间长了之后速度就比不过Java版了。这是HotSpot的优化方式带来的性能特性，同时也是许多虚拟机的共同点：跨越native边界会对优化有阻碍作用，它就像个黑箱一样让虚拟机难以分析也将其内联，于是运行时间长了之后反而是托管版本的代码更快些。</p>
<p>为了尽可能地减少性能损耗，HotSpot JDK采用“inflation”的技巧：让Java方法在被反射调用时，开头若干次使用native版，等反射调用次数超过阈值时则生成一个专用的MethodAccessor实现类，生成其中的invoke()方法的字节码，以后对该Java方法的反射调用就会使用Java版本。 这项优化是从JDK 1.4开始的。</p>
<p>研究<code>ReflectionFactory.newMethodAccessor()</code>生产<code>MethodAccessor</code>对象的逻辑，一开始(native版)会生产<code>NativeMethodAccessorImpl</code>和<code>DelegatingMethodAccessorImpl</code>两个对象。<br><code>DelegatingMethodAccessorImpl</code>的源码如下：</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">/** Delegates its invocation to another MethodAccessorImpl and can
    change its delegate at run time. */
class DelegatingMethodAccessorImpl extends MethodAccessorImpl {
    private MethodAccessorImpl delegate;
    DelegatingMethodAccessorImpl(MethodAccessorImpl delegate) {
        setDelegate(delegate);
    }
    public Object invoke(Object obj, Object[] args)
        throws IllegalArgumentException, InvocationTargetException
    {
        return delegate.invoke(obj, args);
    }
    void setDelegate(MethodAccessorImpl delegate) {
        this.delegate = delegate;
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>它其实是一个中间层，方便在native版与Java版的MethodAccessor之间进行切换。<br>然后下面就是native版MethodAccessor的Java方面的声明：<br>sun.reflect.NativeMethodAccessorImpl：</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">/** Used only for the first few invocations of a Method; afterward,
    switches to bytecode-based implementation */
class NativeMethodAccessorImpl extends MethodAccessorImpl {
    private Method method;
    private DelegatingMethodAccessorImpl parent;
    private int numInvocations;
    NativeMethodAccessorImpl(Method method) {
        this.method = method;
    }
    public Object invoke(Object obj, Object[] args)
        throws IllegalArgumentException, InvocationTargetException
    {
        // We can't inflate methods belonging to vm-anonymous classes because
        // that kind of class can't be referred to by name, hence can't be
        // found from the generated bytecode.
        if (++numInvocations > ReflectionFactory.inflationThreshold()
                && !ReflectUtil.isVMAnonymousClass(method.getDeclaringClass())) {
            MethodAccessorImpl acc = (MethodAccessorImpl)
                new MethodAccessorGenerator().
                    generateMethod(method.getDeclaringClass(),
                                   method.getName(),
                                   method.getParameterTypes(),
                                   method.getReturnType(),
                                   method.getExceptionTypes(),
                                   method.getModifiers());
            parent.setDelegate(acc);
        }
        return invoke0(method, obj, args);
    }
    void setParent(DelegatingMethodAccessorImpl parent) {
        this.parent = parent;
    }
    private static native Object invoke0(Method m, Object obj, Object[] args);
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>每次NativeMethodAccessorImpl.invoke()方法被调用时，程序调用计数器都会增加1，看看是否超过阈值；一旦超过，则调用MethodAccessorGenerator.generateMethod()来生成Java版的MethodAccessor的实现类，并且改变DelegatingMethodAccessorImpl所引用的MethodAccessor为Java版。后续经由DelegatingMethodAccessorImpl.invoke()调用到的就是Java版的实现了。<br>到这里，我们已经追寻到native版的invoke方法在Java一侧声明的最底层 - invoke0了，下面我们将深入到HotSpot JVM中去研究其具体实现。</p>
<h4 id="寻根溯源-在JVM层面探究invoke0方法"><a href="#寻根溯源-在JVM层面探究invoke0方法" class="headerlink" title="寻根溯源 - 在JVM层面探究invoke0方法"></a>寻根溯源 - 在JVM层面探究invoke0方法</h4><p>invoke0方法是一个native方法,它在HotSpot JVM里调用JVM_InvokeMethod函数:</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">JNIEXPORT jobject JNICALL Java_sun_reflect_NativeMethodAccessorImpl_invoke0(JNIEnv *env, jclass unused, jobject m, jobject obj, jobjectArray args){
    return JVM_InvokeMethod(env, m, obj, args);
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>openjdk/hotspot/src/share/vm/prims/jvm.cpp</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">JVM_ENTRY(jobject, JVM_InvokeMethod(JNIEnv *env, jobject method, jobject obj, jobjectArray args0))
  JVMWrapper("JVM_InvokeMethod");
  Handle method_handle;
  if (thread->stack_available((address) &method_handle) >= JVMInvokeMethodSlack) {
    method_handle = Handle(THREAD, JNIHandles::resolve(method));
    Handle receiver(THREAD, JNIHandles::resolve(obj));
    objArrayHandle args(THREAD, objArrayOop(JNIHandles::resolve(args0)));
    oop result = Reflection::invoke_method(method_handle(), receiver, args, CHECK_NULL);
    jobject res = JNIHandles::make_local(env, result);
    if (JvmtiExport::should_post_vm_object_alloc()) {
      oop ret_type = java_lang_reflect_Method::return_type(method_handle());
      assert(ret_type != NULL, "sanity check: ret_type oop must not be NULL!");
      if (java_lang_Class::is_primitive(ret_type)) {
        // Only for primitive type vm allocates memory for java object.
        // See box() method.
        JvmtiExport::post_vm_object_alloc(JavaThread::current(), result);
      }
    }
    return res;
  } else {
    THROW_0(vmSymbols::java_lang_StackOverflowError());
  }
JVM_END
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>其关键部分为Reflection::invoke_method:<br>openjdk/hotspot/src/share/vm/runtime/reflection.cpp</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">oop Reflection::invoke_method(oop method_mirror, Handle receiver, objArrayHandle args, TRAPS) {
  oop mirror             = java_lang_reflect_Method::clazz(method_mirror);
  int slot               = java_lang_reflect_Method::slot(method_mirror);
  bool override          = java_lang_reflect_Method::override(method_mirror) != 0;
  objArrayHandle ptypes(THREAD, objArrayOop(java_lang_reflect_Method::parameter_types(method_mirror)));
  oop return_type_mirror = java_lang_reflect_Method::return_type(method_mirror);
  BasicType rtype;
  if (java_lang_Class::is_primitive(return_type_mirror)) {
    rtype = basic_type_mirror_to_basic_type(return_type_mirror, CHECK_NULL);
  } else {
    rtype = T_OBJECT;
  }
  instanceKlassHandle klass(THREAD, java_lang_Class::as_Klass(mirror));
  Method* m = klass->method_with_idnum(slot);
  if (m == NULL) {
    THROW_MSG_0(vmSymbols::java_lang_InternalError(), "invoke");
  }
  methodHandle method(THREAD, m);
  return invoke(klass, method, receiver, override, ptypes, rtype, args, true, THREAD);
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这里面又会涉及到Java的对象模型(klass和oop)，以后继续补充。(<strong>留坑</strong>)</p>
<h4 id="寻根溯源-Java版的实现"><a href="#寻根溯源-Java版的实现" class="headerlink" title="寻根溯源 - Java版的实现"></a>寻根溯源 - Java版的实现</h4><p>Java版MethodAccessor的生成使用MethodAccessorGenerator实现，由于代码太长，这里就不贴代码了，只贴一下开头的注释：</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">/** Generator for sun.reflect.MethodAccessor and
    sun.reflect.ConstructorAccessor objects using bytecodes to
    implement reflection. A java.lang.reflect.Method or
    java.lang.reflect.Constructor object can delegate its invoke or
    newInstance method to an accessor using native code or to one
    generated by this class. (Methods and Constructors were merged
    together in this class to ensure maximum code sharing.) */
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这里运用了asm动态生成字节码技术（sun.reflect.ClassFileAssembler)，原理比较复杂，后面讲到AOP要用到asm技术的时候再深入了解一下吧。</p>
<h4 id="本篇总结"><a href="#本篇总结" class="headerlink" title="本篇总结"></a>本篇总结</h4><p>简单地画了个图表示invoke方法的过程，日后再更时序图：</p>
<p><a href="http://img.blog.csdn.net/20150626130739796" target="_blank" rel="noopener"><img src="http://img.blog.csdn.net/20150626130739796" alt="invoke方法的过程"></a></p>
<h4 id="番外篇"><a href="#番外篇" class="headerlink" title="番外篇"></a>番外篇</h4><ol>
<li>MagicAccessorImpl是什么鬼？</li>
</ol>
<p>原本Java的安全机制使得不同类之间不是任意信息都可见，但JDK里面专门设了个MagicAccessorImpl标记类开了个后门来允许不同类之间信息可以互相访问（由JVM管理）：</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">/** <P> MagicAccessorImpl (named for parity with FieldAccessorImpl and
    others, not because it actually implements an interface) is a
    marker class in the hierarchy. All subclasses of this class are
    "magically" granted access by the VM to otherwise inaccessible
    fields and methods of other classes. It is used to hold the code
    for dynamically-generated FieldAccessorImpl and MethodAccessorImpl
    subclasses. (Use of the word "unsafe" was avoided in this class's
    name to avoid confusion with {@link sun.misc.Unsafe}.) </P>
    <P> The bug fix for 4486457 also necessitated disabling
    verification for this class and all subclasses, as opposed to just
    SerializationConstructorAccessorImpl and subclasses, to avoid
    having to indicate to the VM which of these dynamically-generated
    stub classes were known to be able to pass the verifier. </P>
    <P> Do not change the name of this class without also changing the
    VM's code. </P> */
class MagicAccessorImpl {
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ol>
<li>@CallerSensitive注解又是什么鬼？</li>
</ol>
<p>详见：<a href="http://openjdk.java.net/jeps/176" target="_blank" rel="noopener">JEP 176: Mechanical Checking of Caller-Sensitive Methods</a></p>
<blockquote>
<p>Summary: Improve the security of the JDK’s method-handle implementation by replacing the existing hand-maintained list of caller-sensitive methods with a mechanism that accurately identifies such methods and allows their callers to be discovered reliably.</p>
</blockquote>
<p>JDK 1.8才引进了这个注解，因此在老版本的反射实现里并没有这个玩意。这是它的定义：</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">/**
 * A method annotated @CallerSensitive is sensitive to its calling class,
 * via {@link sun.reflect.Reflection#getCallerClass Reflection.getCallerClass},
 * or via some equivalent.
 *
 * @author John R. Rose
 */
@Retention(RetentionPolicy.RUNTIME)
@Target({METHOD})
public @interface CallerSensitive {
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>简而言之，用<code>@CallerSensitive</code>注解修饰的方法从一开始就知道具体调用它的对象，这样就不用再经过一系列的检查才能确定具体调用它的对象了。它实际上是调用<code>sun.reflect.Reflection.getCallerClass</code>方法。</p>
<p>Reflection类位于调用栈中的0帧位置，<code>sun.reflect.Reflection.getCallerClass()</code>方法返回调用栈中从0帧开始的第x帧中的类实例。该方法提供的机制可用于确定调用者类，从而实现“感知调用者（Caller Sensitive）”的行为，即允许应用程序根据调用类或调用栈中的其它类来改变其自身的行为。</p>
<h3 id="HTTP请求的GET和POST方式的区别"><a href="#HTTP请求的GET和POST方式的区别" class="headerlink" title="HTTP请求的GET和POST方式的区别"></a>HTTP请求的GET和POST方式的区别</h3><p>最直观的区别就是GET把参数包含在URL中，POST通过request body传递参数。</p>
<ul>
<li>GET在浏览器回退时是无害的，而POST会再次提交请求。</li>
<li>GET产生的URL地址可以被Bookmark，而POST不可以。</li>
<li>GET请求会被浏览器主动cache，而POST不会，除非手动设置。 </li>
<li>GET请求只能进行url编码，而POST支持多种编码方式。</li>
<li>GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。</li>
<li>GET请求在URL中传送的参数是有长度限制的，而POST么有。</li>
<li>对参数的数据类型，GET只接受ASCII字符，而POST没有限制。</li>
<li>GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。</li>
<li>GET参数通过URL传递，POST放在Request body中。</li>
</ul>
<p>HTTP的底层是TCP/IP。所以GET和POST的底层也是TCP/IP，也就是说，GET/POST都是TCP链接。GET和POST能做的事情是一样一样的。你要给GET加上request body，给POST带上url参数，技术上是完全行的通的。 </p>
<p>HTTP设定了有GET, POST, PUT, DELETE等等，HTTP规定，当执行GET请求的时候，要给请求贴上GET的标签（设置method为GET），而且要求把传送的数据放在url中以方便记录。如果是POST请求，就要在贴上POST的标签，并把数据放在request body里。当然，也可以在GET的时候往request body内偷偷藏点数据，但是这是很不光彩；也可以在POST的时候在url上也放一些数据。HTTP只是个行为准则，而TCP才是GET和POST怎么实现的基本。</p>
<p>不同的浏览器（发起http请求）和服务器（接受http)。大多数浏览器通常都会限制url长度在2K，而（大多数）服务器最多处理64K大小的url。超过的部分，恕不处理。如果你用GET服务，在request body偷偷藏了数据，不同服务器的处理方式也是不同的，有些服务器会帮你卸货，读出数据，有些服务器直接忽略，所以，虽然GET可以带request body，也不能保证一定能被接收到。</p>
<p>GET和POST还有一个重大区别，简单的说：</p>
<p>​    GET产生一个TCP数据包；POST产生两个TCP数据包。</p>
<p>长的说：</p>
<p>​    对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；</p>
<p>而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。</p>
<p>因为POST需要两步，时间上消耗的要多一点，看起来GET比POST更有效。因此Yahoo团队有推荐用GET替换POST来优化网站性能。但这是一个坑！跳入需谨慎。为什么？</p>
<ol>
<li><p>GET与POST都有自己的语义，不能随便混用。</p>
</li>
<li><p>据研究，在网络环境好的情况下，发一次包的时间和发两次包的时间差别基本可以无视。而在网络环境差的情况下，两次包的TCP在验证数据包完整性上，有非常大的优点。</p>
</li>
<li><p>并不是所有浏览器都会在POST中发送两次包，Firefox就只发送一次。</p>
</li>
</ol>
<h3 id="session和cookie的区别"><a href="#session和cookie的区别" class="headerlink" title="session和cookie的区别"></a>session和cookie的区别</h3><p>由于http的无状态性，为了使某个域名下的所有网页能够共享某些数据，session和cookie出现了。客户端访问服务器的流程如下</p>
<ul>
<li>首先，客户端会发送一个http请求到服务器端。</li>
<li><p>服务器端接受客户端请求后，建立一个<code>session</code>，并发送一个<code>http</code>响应到客户端，这个响应头，其中就包含Set-Cookie头部。该头部包含了<code>sessionId</code>。<code>Set-Cookie</code>格式如下，具体请看<a href="http://bubkoo.com/2014/04/21/http-cookies-explained/" target="_blank" rel="noopener">Cookie详解</a></p>
<blockquote>
<p>Set-Cookie: value[; expires=date][; domain=domain][; path=path][; secure]</p>
</blockquote>
</li>
<li>在客户端发起的第二次请求，假如服务器给了<code>set-Cookie</code>，浏览器会自动在请求头中添加cookie</li>
<li>服务器接收请求，分解<code>cookie</code>，验证信息，核对成功后返回response给客户端</li>
</ul>
<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><ul>
<li>cookie只是实现session的其中一种方案。虽然是最常用的，但并不是唯一的方法。禁用cookie后还有其他方法存储，比如放在url中</li>
<li>现在大多都是Session + Cookie，但是只用session不用cookie，或是只用cookie，不用session在理论上都可以保持会话状态。可是实际中因为多种原因，一般不会单独使用</li>
<li>用session只需要在客户端保存一个id，实际上大量数据都是保存在服务端。如果全部用cookie，数据量大的时候客户端是没有那么多空间的。</li>
<li>如果只用cookie不用session，那么账户信息全部保存在客户端，一旦被劫持，全部信息都会泄露。并且客户端数据量变大，网络传输的数据量也会变大</li>
</ul>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p><strong>简而言之, session 有如用户信息档案表, 里面包含了用户的认证信息和登录状态等信息. 而 cookie 就是用户通行证</strong></p>
<h4 id="token"><a href="#token" class="headerlink" title="token"></a>token</h4><p>token 也称作令牌，由uid+time+sign[+固定参数]<br>token 的认证方式类似于<strong>临时的证书签名</strong>, 并且是一种服务端无状态的认证方式, 非常适合于 REST API 的场景. 所谓无状态就是服务端并不会保存身份认证相关的数据。</p>
<h4 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h4><ul>
<li>uid: 用户唯一身份标识</li>
<li>time: 当前时间的时间戳</li>
<li>sign: 签名, 使用 hash/encrypt 压缩成定长的十六进制字符串，以防止第三方恶意拼接</li>
<li>固定参数(可选): 将一些常用的固定参数加入到 token 中是为了避免重复查库</li>
</ul>
<h4 id="存放"><a href="#存放" class="headerlink" title="存放"></a>存放</h4><p>token在客户端一般存放于<code>localStorage</code>，cookie，或<code>sessionStorage</code>中。在服务器一般存于数据库中</p>
<h4 id="token认证流程"><a href="#token认证流程" class="headerlink" title="token认证流程"></a>token认证流程</h4><p>token 的认证流程与cookie很相似</p>
<ul>
<li>用户登录，成功后服务器返回Token给客户端。</li>
<li>客户端收到数据后保存在客户端</li>
<li>客户端再次访问服务器，将token放入headers中</li>
<li>服务器端采用filter过滤器校验。校验成功则返回请求数据，校验失败则返回错误码</li>
</ul>
<h4 id="token可以抵抗csrf，cookie-session不行"><a href="#token可以抵抗csrf，cookie-session不行" class="headerlink" title="token可以抵抗csrf，cookie+session不行"></a>token可以抵抗<code>csrf</code>，cookie+session不行</h4><p>假如用户正在登陆银行网页，同时登陆了攻击者的网页，并且银行网页未对csrf攻击进行防护。攻击者就可以在网页放一个表单，该表单提交<code>sr</code>c为<code>http://www.bank.com/api/transfer</code>，body为<code>count=1000&amp;to=Tom</code>。倘若是session+cookie，用户打开网页的时候就已经转给Tom 1000元了.因为<code>form</code> 发起的 POST 请求并不受到浏览器同源策略的限制，因此可以任意地使用其他域的 Cookie 向其他域发送 POST 请求，形成 <code>CSRF</code> 攻击。在post请求的瞬间，cookie会被浏览器自动添加到请求头中。但<code>token</code>不同，<code>token</code>是开发者为了防范csrf而特别设计的令牌，浏览器不会自动添加到headers里，攻击者也无法访问用户的token，所以提交的表单无法通过服务器过滤，也就无法形成攻击。</p>
<h4 id="分布式情况下的session和token"><a href="#分布式情况下的session和token" class="headerlink" title="分布式情况下的session和token"></a>分布式情况下的session和token</h4><p>我们已经知道session时有状态的，一般存于服务器内存或硬盘中，当服务器采用分布式或集群时，session就会面对负载均衡问题。</p>
<ul>
<li>负载均衡多服务器的情况，不好确认当前用户是否登录，因为多服务器不共享session。这个问题也可以将session存在一个服务器中来解决，但是就不能完全达到负载均衡的效果。当今的几种<a href="http://blog.51cto.com/zhibeiwang/1965018" target="_blank" rel="noopener">解决session负载均衡</a>的方法。</li>
</ul>
<p>而token是无状态的，token字符串里就保存了所有的用户信息</p>
<ul>
<li>客户端登陆传递信息给服务端，服务端收到后把用户信息加密（token）传给客户端，客户端将token存放于localStroage等容器中。客户端每次访问都传递token，服务端解密token，就知道这个用户是谁了。通过cpu加解密，服务端就不需要存储session占用存储空间，就很好的解决负载均衡多服务器的问题了。这个方法叫做<a href="https://huanqiang.wang/2017/12/28/JWT 介绍/" target="_blank" rel="noopener">JWT(Json Web Token)</a></li>
</ul>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul>
<li>session存储于服务器，可以理解为一个状态列表，拥有一个唯一识别符号sessionId，通常存放于cookie中。服务器收到cookie后解析出sessionId，再去session列表中查找，才能找到相应session。依赖cookie</li>
<li>cookie类似一个令牌，装有sessionId，存储在客户端，浏览器通常会自动添加。</li>
<li>token也类似一个令牌，无状态，用户信息都被加密到token中，服务器收到token后解密就可知道是哪个用户。需要开发者手动添加。</li>
<li><code>jwt</code>只是一个跨域认证的方案</li>
</ul>
<h4 id="注意区别"><a href="#注意区别" class="headerlink" title="注意区别"></a>注意区别</h4><h4 id="1、存储位置不同"><a href="#1、存储位置不同" class="headerlink" title="1、存储位置不同"></a>1、存储位置不同</h4><ul>
<li><p>cookie的数据信息存放在客户端浏览器上。</p>
</li>
<li><p>session的数据信息存放在服务器上。</p>
<h4 id="2、存储容量不同"><a href="#2、存储容量不同" class="headerlink" title="2、存储容量不同"></a>2、存储容量不同</h4></li>
<li><p>单个cookie保存的数据<code>&lt;=4KB</code>，一个站点最多保存20个Cookie。</p>
</li>
<li><p>对于session来说并没有上限，但出于对服务器端的性能考虑，session内不要存放过多的东西，并且设置session删除机制。</p>
<h4 id="3、存储方式不同"><a href="#3、存储方式不同" class="headerlink" title="3、存储方式不同"></a>3、存储方式不同</h4></li>
<li><p>cookie中只能保管ASCII字符串，并需要通过编码方式存储为Unicode字符或者二进制数据。</p>
</li>
<li><p>session中能够存储任何类型的数据，包括且不限于string，integer，list，map等。</p>
<h4 id="4、隐私策略不同"><a href="#4、隐私策略不同" class="headerlink" title="4、隐私策略不同"></a>4、隐私策略不同</h4></li>
<li><p>cookie对客户端是可见的，别有用心的人可以分析存放在本地的cookie并进行cookie欺骗，所以它是不安全的。</p>
</li>
<li><p>session存储在服务器上，对客户端是透明对，不存在敏感信息泄漏的风险。</p>
<h4 id="5、有效期上不同"><a href="#5、有效期上不同" class="headerlink" title="5、有效期上不同"></a>5、有效期上不同</h4></li>
<li><p>开发可以通过设置cookie的属性，达到使cookie长期有效的效果。</p>
</li>
<li><p>session依赖于名为<code>JSESSIONID</code>的cookie，而cookie <code>JSESSIONID</code>的过期时间默认为-1，只需关闭窗口该session就会失效，因而session不能达到长期有效的效果。</p>
<h4 id="6、服务器压力不同"><a href="#6、服务器压力不同" class="headerlink" title="6、服务器压力不同"></a>6、服务器压力不同</h4></li>
<li><p>cookie保管在客户端，不占用服务器资源。对于并发用户十分多的网站，cookie是很好的选择。</p>
</li>
<li><p>session是保管在服务器端的，每个用户都会产生一个session。假如并发访问的用户十分多，会产生十分多的session，耗费大量的内存。</p>
<h4 id="7、浏览器支持不同"><a href="#7、浏览器支持不同" class="headerlink" title="7、浏览器支持不同"></a>7、浏览器支持不同</h4><p>假如客户端浏览器不支持cookie：</p>
</li>
<li><p>cookie是需要客户端浏览器支持的，假如客户端禁用了cookie，或者不支持cookie，则会话跟踪会失效。关于WAP上的应用，常规的cookie就派不上用场了。</p>
</li>
<li><p>运用session需要使用URL地址重写的方式。一切用到session程序的URL都要进行URL地址重写，否则session会话跟踪还会失效。</p>
<p>假如客户端支持cookie：</p>
</li>
<li><p>cookie既能够设为本浏览器窗口以及子窗口内有效，也能够设为一切窗口内有效。</p>
</li>
<li><p>session只能在本窗口以及子窗口内有效。</p>
<h4 id="8、跨域支持上不同"><a href="#8、跨域支持上不同" class="headerlink" title="8、跨域支持上不同"></a>8、跨域支持上不同</h4></li>
<li><p>cookie支持跨域名访问。</p>
</li>
<li>session不支持跨域名访问。</li>
</ul>
<h3 id="session-分布式处理"><a href="#session-分布式处理" class="headerlink" title="session 分布式处理"></a>session 分布式处理</h3><h3 id="JDBC-流程"><a href="#JDBC-流程" class="headerlink" title="JDBC 流程"></a>JDBC 流程</h3><p><strong>通过JDBC操作数据库——步骤：</strong></p>
<p>　　第1步：注冊驱动 (仅仅做一次)</p>
<p>　　第2步：建立连接(Connection)</p>
<p>　　第3步：创建运行SQL的语句(Statement)</p>
<p>　　第4步：运行语句</p>
<p>　　第5步：处理运行结果(ResultSet)</p>
<p>　　第6步：释放资源</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">
//1. 使用JDBC第一步：载入驱动

　　注冊驱动有三种方式：

　　1. Class.forName(“com.mysql.jdbc.Driver”);

//推荐这样的方式，不会对详细的驱动类产生依赖

　　2. DriverManager.registerDriver(com.mysql.jdbc.Driver);

//会对详细的驱动类产生依赖

　　3. System.setProperty(“jdbc.drivers”, “driver1:driver2”);

//尽管不会对详细的驱动类产生依赖；但注冊不太方便。所以非常少使用

2. 使用JDBC第二步：建立连接

　　通过Connection建立连接，Connection是一个接口类。其功能是与数据库进行连接（会话）。

　　建立Connection接口类对象：

　　Connection conn =DriverManager.getConnection(url, user, password);

　　当中URL的格式要求为：

　　JDBC:子协议:子名称//主机名:port/数据库名？属性名=属性值&…

　　如："jdbc:mysql://localhost:3306/test“

　　user即为登录数据库的username，如root

　　password即为登录数据库的密码，为空就填””

3. 使用JDBC第三步：创建运行对象

　　运行对象Statement负责运行SQL语句。由Connection对象产生。

　　Statement st = connection.createStatement();

　　Statement接口类还派生出两个接口类PreparedStatement和CallableStatement，这两个接口类对象为我们提供了更加强大的数据訪问功能。

　　PreparedStatement能够对SQL语句进行预编译，这样防止了SQL注入提高了安全性。

　　PreparedStatement  ps=connection.prepareStatement( "update user set id=? where username=?”); 
//sql语句中庸 ？ 作为通配符，变量值通过参数设入：ps.setObject(1, object);

　　而且预编译结果能够存储在PreparedStatement对象中。当多次运行SQL语句时能够提高效率。

　　作为Statement的子类，PreparedStatement继承了Statement的全部函数。

　　CallableStatement接口

　　CallableStatement类继承了PreparedStatement类，他主要用于运行SQL存储过程。

　　在JDBC中运行SQL存储过程须要转义。

　　JDBC API提供了一个SQL存储过程的转义语法：

　　{call<procedure-name>[<arg1>,<arg2>, ...]}

　　procedure-name：是所要运行的SQL存储过程的名字

　　[<arg1>,<arg2>, ...]：是相相应的SQL存储过程所须要的參数

4. 使用JDBC第四步：运行SQL语句

　　运行对象Statement 或 PreparedStatement 提供两个经常使用的方法来运行SQL语句。

　　executeQuery(Stringsql),该方法用于运行实现查询功能的sql语句。返回类型为ResultSet（结果集）。

　　如：ResultSet  rs =st.executeQuery(sql);

　　executeUpdate(Stringsql),该方法用于运行实现增、删、改功能的sql语句，返回类型为int，即受影响的行数。

　　如：int flag = st.executeUpdate(sql);

5. 使用JDBC第五步：处理运行结果

　　ResultSet对象

　　ResultSet对象负责保存Statement运行后所产生的查询结果。

　　结果集ResultSet是通过游标来操作的。

　　游标就是一个可控制的、能够指向随意一条记录的指针。

　　有了这个指针我们就能轻易地指出我们要对结果集中的哪一条记录进行改动、删除，或者要在哪一条记录之前插入数据。一个结果集对象中仅仅包括一个游标。

 　　另外，借助ResultSetMetaData ，可以将数据表的结构信息都查出来。

　　ResultSetMetaData rsmd= resultSet.getMetaData();

使用JDBC 
6. 第六步——释放资源

　　数据库资源不关闭，其占用的内存不会被释放，徒耗资源，影响系统。
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="MVC-设计思想"><a href="#MVC-设计思想" class="headerlink" title="MVC 设计思想"></a>MVC 设计思想</h3><p>MVC(Model View Controller)是一种软件设计的框架模式，它采用模型(Model)-视图(View)-控制器(controller)的方法把业务逻辑、数据与界面显示分离。把众多的业务逻辑聚集到一个部件里面，当然这种比较官方的解释是不能让我们足够清晰的理解什么是MVC的。用通俗的话来讲，MVC的理念就是把数据处理、数据展示(界面)和程序/用户的交互三者分离开的一种编程模式。</p>
<p>MVC框架模式是一种复合模式，MVC的三个核心部件分别是</p>
<p>1：Model(模型)：所有的用户数据、状态以及程序逻辑，独立于视图和控制器</p>
<p>2：View(视图)：呈现模型，类似于Web程序中的界面，视图会从模型中拿到需要展现的状态以及数据，对于相同的数据可以有多种不同的显示形式(视图)</p>
<p>3：Controller(控制器)：负责获取用户的输入信息，进行解析并反馈给模型，通常情况下一个视图具有一个控制器</p>
<h6 id="1-2：为什么要使用MVC"><a href="#1-2：为什么要使用MVC" class="headerlink" title="1.2：为什么要使用MVC"></a>1.2：为什么要使用MVC</h6><p>程序通过将M(Model)和V(View)的代码分离，实现了前后端代码的分离，会带来几个好处</p>
<ol>
<li><p>可以使同一个程序使用不同的表现形式，如果控制器反馈给模型的数据发生了变化，那么模型将及时通知有关的视图，视图会对应的刷新自己所展现的内容</p>
</li>
<li><p>因为模型是独立于视图的，所以模型可复用，模型可以独立的移植到别的地方继续使用</p>
</li>
<li><p>前后端的代码分离，使项目开发的分工更加明确，程序的测试更加简便，提高开发效率<br>其实控制器的功能类似于一个中转站，会决定调用那个模型去处理用户请求以及调用哪个视图去呈现给用户</p>
</li>
</ol>
<h6 id="1-3：JavaWeb中MVC模式的应用"><a href="#1-3：JavaWeb中MVC模式的应用" class="headerlink" title="1.3：JavaWeb中MVC模式的应用"></a>1.3：JavaWeb中MVC模式的应用</h6><p>在JavaWeb程序中，MVC框架模式是经常用到的，举一个Web程序的结构可以更好的理解MVC的理念</p>
<p>V：View视图，Web程序中指用户可以看到的并可以与之进行数据交互的界面，比如一个Html网页界面，或者某些客户端的界面，在前面讲过，MVC可以为程序处理很多不同的视图，用户在视图中进行输出数据以及一系列操作，注意：视图中不会发生数据的处理操作。</p>
<p>M：Model模型：进行所有数据的处理工作，模型返回的数据是中立的，和数据格式无关，一个模型可以为多个视图来提供数据，所以模型的代码重复性比较低</p>
<p>C：Controller控制器：负责接受用户的输入，并且调用模型和视图去完成用户的需求，控制器不会输出也不会做出任何处理，只会接受请求并调用模型构件去处理用户的请求，然后在确定用哪个视图去显示返回的数据</p>
<h6 id="1-4：Web程序中MVC模式的优点"><a href="#1-4：Web程序中MVC模式的优点" class="headerlink" title="1.4：Web程序中MVC模式的优点"></a>1.4：Web程序中MVC模式的优点</h6><ul>
<li><p>耦合性低：视图(页面)和业务层(数据处理)分离，一个应用的业务流程或者业务规则的改变只需要改动MVC中的模型即可，不会影响到控制器与视图</p>
</li>
<li><p>部署快，成本低：MVC使开发和维护用户接口的技术含量降低。使用MVC模式使开发时间得到相当大的缩减，它使程序员（Java开发人员）集中精力于业务逻辑，界面程序员（HTML和JSP开发人员）集中精力于表现形式上</p>
</li>
<li><p>可维护性高：分离视图层和业务逻辑层也使得WEB应用更易于维护和修改</p>
</li>
</ul>
<h6 id="1-5：Web程序中MVC模式的缺点"><a href="#1-5：Web程序中MVC模式的缺点" class="headerlink" title="1.5：Web程序中MVC模式的缺点"></a>1.5：Web程序中MVC模式的缺点</h6><p>调试困难：因为模型和视图要严格的分离，这样也给调试应用程序带来了一定的困难，每个构件在使用之前都需要经过彻底的测试</p>
<p>不适合小型，中等规模的应用程序：在一个中小型的应用程序中，强制性的使用MVC进行开发，往往会花费大量时间，并且不能体现MVC的优势，同时会使开发变得繁琐</p>
<p>增加系统结构和实现的复杂性：对于简单的界面，严格遵循MVC，使模型、视图与控制器分离，会增加结构的复杂性，并可能产生过多的更新操作，降低运行效率</p>
<p>视图与控制器间的过于紧密的连接并且降低了视图对模型数据的访问：视图与控制器是相互分离，但却是联系紧密的部件，视图没有控制器的存在，其应用是很有限的，反之亦然，这样就妨碍了他们的独立重用。依据模型操作接口的不同，视图可能需要多次调用才能获得足够的显示数据。对未变化数据的不必要的频繁访问，也将损害操作性能</p>
<h5 id="2、Spring-MVC框架"><a href="#2、Spring-MVC框架" class="headerlink" title="2、Spring MVC框架"></a>2、Spring MVC框架</h5><p>现在MVC框架已经有很多了，Struts、Webwork，新兴的MVC框架有Spring MVC、JSF等等，本文主要介绍Spring MVC的设计理念</p>
<p>Struts1.0是基于webwork的MVC框架，里面有很多类的继承关系，耦合性太高，之后推出了struts2.0，但是这个MVC框架对于视图的解析还是存在一些小的不妥之处，所以产生了Spring MVC</p>
<h6 id="2-1、Spring-MVC简介及特点"><a href="#2-1、Spring-MVC简介及特点" class="headerlink" title="2.1、Spring MVC简介及特点"></a>2.1、Spring MVC简介及特点</h6><p>Spring MVC采用了松散耦合的可插拔组件结构，比其他的MVC框架更具有灵活性和扩展性，Spring MVC通过使用一套注解，使一个Java类成为前端控制器(Controller)，不需要实现任何接口，同时，Spring MVC支持RES形式的URL请求，除此之外，Spring MVC在在数据绑定、视图解析、本地化处理及静态资源处理上都有许多不俗的表现。</p>
<p>Spring MVC围绕DispatcherServlet(前端控制器)为中心展开，DispatcherServlet(前端控制器)是Spring MVC的中枢，和MVC的思想一样，它负责从视图获取用户请求并且分派给相应的处理器处理，并决定用哪个视图去把数据呈现给给用户</p>
<h6 id="Spring-MVC特点"><a href="#Spring-MVC特点" class="headerlink" title="Spring MVC特点"></a>Spring MVC特点</h6><ol>
<li>让我们能非常简单的设计出干净的Web层和薄薄的Web层；</li>
<li>进行更简洁的Web层的开发；</li>
<li>天生与Spring框架集成（如IoC容器、AOP等）;</li>
<li>提供强大的约定大于配置的契约式编程支持；</li>
<li>能简单的进行Web层的单元测试；</li>
<li>支持灵活的URL到页面控制器的映射；</li>
<li>非常容易与其它视图技术集成，如Velocity、FreeMarker等，因为模型数据不放在特定的API里，而是放在一 个Model里（Map数据结构实现，因此很容易被其他框架使用）；</li>
<li>非常灵活的数据验证、格式化和数据绑定机制，能使用任何对象进行数据绑定，不必实现特定框架的API；</li>
<li>提供一套强大的JSP标签库，简化JSP开发；</li>
<li>支持灵活的本地化、主题等解析；</li>
<li>更加简单的异常处理；</li>
<li>对静态资源的支持； 支持Restful风格。</li>
</ol>
<h6 id="2-2：Spring-MVC请求响应"><a href="#2-2：Spring-MVC请求响应" class="headerlink" title="2.2：Spring MVC请求响应"></a>2.2：Spring MVC请求响应</h6><p>SpringMVC把视图渲染、请求处理、模型创建分离了，遵循了MVC框架模式的思想</p>
<p>SpringMVC的请求相应要经过七个阶段，蓝色的方框是Spring框架已经实现好的，第二阶段到第六阶段对应着Spring MVC中的一些核心理念，分别是前端控制器、处理映射器、控制器(处理器)、视图解析器、视图。要注意的是：前端控制器和控制器不是一个东西，前端控制器负责任务分发，控制器是模型的一部分，负责业务和数据的处理</p>
<p>SpringMVC核心控制类的请求流程</p>
<h6 id="SpringMVC的请求相应步骤如下"><a href="#SpringMVC的请求相应步骤如下" class="headerlink" title="SpringMVC的请求相应步骤如下"></a>SpringMVC的请求相应步骤如下</h6><p>1、用户向服务器发送请求，请求被Spring 前端控制Servelt DispatcherServlet捕获</p>
<p>2、DispatcherServlet对请求URL进行解析，得到请求资源标识符（URI）。然后根据该URI，调用HandlerMapping获得该Handler配置的所有相关的对象（包括Handler对象以及Handler对象对应的拦截器），最后以HandlerExecutionChain对象的形式返回</p>
<p>3、DispatcherServlet 根据获得的Handler，选择一个合适的HandlerAdapter。（附注：如果成功获得HandlerAdapter后，此时将开始执行拦截器的preHandler(…)方法）</p>
<p>4、提取Request中的模型数据，填充Handler入参，开始执行Handler（Controller)。 在填充Handler的入参过程中，根据你的配置，Spring将帮你做一些额外的工作</p>
<p>HttpMessageConveter： 将请求消息（如Json、xml等数据）转换成一个对象，将对象转换为指定的响应信息</p>
<pre><code>1. 数据转换：对请求消息进行数据转换。如String转换成Integer、Double等
2. 数据根式化：对请求消息进行数据格式化。 如将字符串转换成格式化数字或格式化日期等
3. 数据验证： 验证数据的有效性（长度、格式等），验证结果存储到BindingResult或Error中
</code></pre><p>5、Handler执行完成后，向DispatcherServlet 返回一个ModelAndView对象</p>
<p>6、根据返回的ModelAndView，选择一个适合的ViewResolver（必须是已经注册到Spring容器中的ViewResolver)返回给DispatcherServlet </p>
<p>7、ViewResolver 结合Model和View，来渲染视图</p>
<p>8、将渲染结果返回给客户端</p>
<h5 id="3、SpringMVC-项目简单搭建"><a href="#3、SpringMVC-项目简单搭建" class="headerlink" title="3、SpringMVC 项目简单搭建"></a>3、SpringMVC 项目简单搭建</h5><p>搭建一个简单的Spring MVC项目，我们只需要有一个Web服务器(tomcat)和一个IDE就可以了，我选择的是tomcat8.5+IDEA,下图是项目的结构</p>
<p>1、首先创建一个Maven项目，添加pom依赖</p>
<pre class="line-numbers language-lang-xml"><code class="language-lang-xml"><?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>com.bittech</groupId>
    <artifactId>springmvc-case</artifactId>
    <version>1.0.0</version>
    <!-- 打包类型 -->
    <packaging>war</packaging>

    <dependencyManagement>
        <dependencies>
            <dependency>
                <groupId>org.springframework</groupId>
                <artifactId>spring-framework-bom</artifactId>
                <version>4.3.9.RELEASE</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>
        </dependencies>
    </dependencyManagement>

    <dependencies>

        <!-- Spring MVC 框架依赖 -->
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-webmvc</artifactId>
        </dependency>

        <!-- Java Servlet API 3.1 -->
        <dependency>
            <groupId>javax.servlet</groupId>
            <artifactId>javax.servlet-api</artifactId>
            <version>3.1.0</version>
            <scope>provided</scope>
        </dependency>

        <!-- JSON 处理库-->
        <dependency>
            <groupId>com.google.code.gson</groupId>
            <artifactId>gson</artifactId>
            <version>2.8.2</version>
        </dependency>

    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>3.7.0</version>
                <configuration>
                    <target>1.8</target>
                    <source>1.8</source>
                </configuration>
            </plugin>
        </plugins>
    </build>

</project>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>因为用到了Spring MVC框架，所以需要导入MVC的依赖，而且，前端控制器是一个Servlet，所以也要导入Servlet API</p>
<p>2、配置Web.xml</p>
<pre class="line-numbers language-lang-xml"><code class="language-lang-xml"><?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee
                      http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd"
         version="3.1">

    <description>This is Java Spring MVC web application</description>

    <!--设置根上下文配置文件-->
    <context-param>
        <param-name>contextConfigLocation</param-name>
        <param-value>classpath:application-context.xml</param-value>
    </context-param>
    <!--注册ContextLoaderListener-->
    <listener>
        <listener-class>
            org.springframework.web.context.ContextLoaderListener
        </listener-class>
    </listener>

    <!--前端控制器，注册DispatcherServlet-->
    <servlet>
    <servlet-name>servlet</servlet-name>
    <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>

    <init-param>
    <param-name>contextConfigLocation</param-name>
        <!--加入配置SpringMVC容器-->
        <param-value>classpath:application-servlet.xml</param-value>
    </init-param>
    </servlet>

    <!--将DispatcherServlet映射到‘/’-->
    <servlet-mapping>
        <servlet-name>servlet</servlet-name>
        <url-pattern>/</url-pattern>
    </servlet-mapping>

</web-app>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>web.xml文件位于src/main/webapp/WEB-INF/web.xml下，在项目的结构里可以看见在WEB-INF目录下有一个view的目录，所有的视图文件都放在这里，此项目的视图为jsp，为什么要把视图文件都放在WEB-INF下呢？因为…</p>
<p>客户端是没有办法看到WEB-INF中的内容的，如果把jsp文件写到webapp里面，抛异常之后代码就会显现出来，网页容易被攻击。视图文件都放在WEB-INF中客户应该访问的是地址，而不是文件，不能暴露实现网站的方式。</p>
<p>3、配置Spring MVC容器</p>
<pre class="line-numbers language-lang-xml"><code class="language-lang-xml"><?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:mvc="http://www.springframework.org/schema/mvc"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd   http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd   http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd">

    <!-- 配置视图解析器 -->
    <bean class="org.springframework.web.servlet.view.InternalResourceViewResolver">
        <property name="prefix" value="/WEB-INF/views/"/>
        <property name="suffix" value=".jsp"/>
    </bean>

    <!-- 扫描包  control -->
    <context:component-scan base-package="com.dxy"/>

    <!-- 启用注解SpringMVC -->
    <mvc:annotation-driven/>

</beans>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre><code>    在配置前端控制器的时候需要把Spring MVC容器作为属性配置到Servlet中，此容器中配置的是视图解析器、控制器(模型)以及SpringMVC的注解驱动。
</code></pre><p>4、配置一个Controller</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">package com.eee.control;

import com.eee.service.MVCservice;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.servlet.ModelAndView;

import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;


@Controller
@RequestMapping(value = "/")
public class Controller1 {

    //业务层访问对象
    private MVCservice mvCservice;

    @RequestMapping(value = {"", "index"}, method = RequestMethod.GET)
    public ModelAndView index() {
        ModelAndView modelAndView = new ModelAndView("index");
        Map<String, String> map = new HashMap<>();
        map.put("datetime", new SimpleDateFormat("yyyy-MM-dd HH:mm:ss").format(new Date()));
        modelAndView.addAllObjects(map);
        return modelAndView;
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>MVC容器中的自动扫描可以扫描到带有@Controller注解的类，Controller类进行业务的处理和数据的访问，例如这个类中有数据访问层的对象，还有类中的一些数据。这个类的返回值为ModelAndView，进行数据处理后返回数据和视图给前端控制器</p>
<p>前端控制器可以通过修改RequestMapping注解中的Value值来改变数据最终反馈到的视图</p>
<p>5、创建一个视图</p>
<pre class="line-numbers language-lang-jsp"><code class="language-lang-jsp"><%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>Spring MVC</title>
</head>
<body>

<h1>当前时间:${datetime}</h1>
</body>
</html>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p> 视图可以提取模型中的数据，例如：这个界面可以提取出模型中的datetime的值</p>
<p>最终呈现给用户的界面</p>
<h3 id="equals-与-区别"><a href="#equals-与-区别" class="headerlink" title="equals 与 == 区别"></a>equals 与 == 区别</h3><p>==和equals()的区别:</p>
<p>==:判断两个字符串在内存中首地址是否相同,即判断两者是否是同一个字符串对象</p>
<p>equles():如果没有重写equals()方法比较的是对象的地址,因为对Object来说对象没有什么属性可以比较,只能比较最底层的地址.</p>
<p>而如果重写equals()方法时,该方法的对象因为是Object的子类,所以调用时会调用子类对象里面的方法.所以只有重写equals()方法后,两者比较的才是内容.或者说重写可以使自己定义比较的规则,不想按照地址去比较。</p>
<p>Java语言对equals()的要求如下，这些要求是必须遵循的：<br>　　对称性：如果x.equals(y)返回是“true”，那么y.equals(x)也应该返回是“true”。<br>　　反射性：x.equals(x)必须返回是“true”。<br>　　类推性：如果x.equals(y)返回是“true”，而且y.equals(z)返回是“true”，那么z.equals(x)也应该返回是“true”。<br>　　一致性：如果x.equals(y)返回是“true”，只要x和y内容一直不变，不管你重复x.equals(y)多少次，返回都是“true”。<br>　　任何情况下，x.equals(null)，永远返回是“false”；x.equals(和x不同类型的对象)永远返回是“false”。<br>　　以上这五点是重写equals()方法时，必须遵守的准则，如果违反会出现意想不到的结果，请大家一定要遵守</p>
<p>　　hashCode方法默认返回对象的地址,String,Integer等封装类型对它进行了重写返回一个整数<br>　　该整数的取值来自于当前字符串的每个字母的编码值.公示如下<br>　　public int hashCode(){<br>　　　　return “abcde”.hashCode();<br>　　}</p>
<p>“==”比较的是地址。</p>
</p></div><div class="share"><span>分享到</span>&nbsp;<span class="soc"><a href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank" class="fa fa-bookmark"></a></span><span class="soc"><a href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));" class="fa fa-weibo"></a></span><span class="soc"><a href="http://twitter.com/home?status=http://yoursite.com/2019/09/10/Java基础篇-篇一（基本功）/%20HeeC' target="_blank" rel="noopener"Blog%20Java基础篇-篇一（基本功）" class="fa fa-twitter"></a></span></div><div class="pagination"><p class="clearfix"><span class="pre pagbuttons"><a role="navigation" href="/2019/09/10/Java%E5%9F%BA%E7%A1%80%E7%AF%87-%E7%AF%87%E4%BA%8C%EF%BC%88%E9%9B%86%E5%90%88%EF%BC%89/" title="Java基础篇-篇二（集合）"><i class="fa fa-angle-double-left"></i>&nbsp;上一篇: Java基础篇-篇二（集合）</a></span><span>&nbsp;</span><span class="next pagbuttons"><a role="navigation" href="/2019/09/07/Java%E6%B3%9B%E5%9E%8B%E6%B7%B1%E5%85%A5/" title="Java泛型深入应用">下一篇: Java泛型深入应用&nbsp;<i class="fa fa-angle-double-right"></i></a></span></p></div><a id="comments"></a><div id="disqus_thread"></div><script>var disqus_shortname = 'HeeC';
var disqus_identifier = '2019/09/10/Java基础篇-篇一（基本功）/';
var disqus_title = 'Java基础篇-篇一（基本功）';
var disqus_url = 'http://yoursite.com/2019/09/10/Java基础篇-篇一（基本功）/';
(function () {
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//HeeC.disqus.com/count.js" async></script></div></div></div><div class="visible-xs site-bottom-footer"><footer><p>&copy;&nbsp;2020&nbsp;<a target="_blank" href="http://yoursite.com" rel="noopener noreferrer">Hee</a></p><p>Theme&nbsp;<a target="_blank" href="https://github.com/SumiMakito/hexo-theme-typography" rel="noopener noreferrer">Typography</a>&nbsp;by&nbsp;<a target="_blank" href="https://www.keep.moe" rel="noopener noreferrer">Makito</a></p><p>Proudly published with&nbsp;<a target="_blank" href="https://hexo.io" rel="noopener noreferrer">Hexo</a></p></footer></div></div></div></div><script src="/js/jquery-3.1.0.min.js"></script><script src="/js/bootstrap.min.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script><script src="/js/google-analytics.js"></script><script src="/js/typography.js"></script><script src="/js/search.js"></script><script src="/js/cursor-effects.js"></script></body></html>